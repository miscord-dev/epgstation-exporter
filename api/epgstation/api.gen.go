// Package epgstation provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen/v2 version v2.0.0 DO NOT EDIT.
package epgstation

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

// Defines values for ChannelType.
const (
	BS  ChannelType = "BS"
	CS  ChannelType = "CS"
	GR  ChannelType = "GR"
	SKY ChannelType = "SKY"
)

// Defines values for ProgramAudioSamplingRate.
const (
	N16000 ProgramAudioSamplingRate = 16000
	N22050 ProgramAudioSamplingRate = 22050
	N24000 ProgramAudioSamplingRate = 24000
	N32000 ProgramAudioSamplingRate = 32000
	N44100 ProgramAudioSamplingRate = 44100
	N48000 ProgramAudioSamplingRate = 48000
)

// Defines values for ProgramVideoResolution.
const (
	N1080i ProgramVideoResolution = "1080i"
	N1080p ProgramVideoResolution = "1080p"
	N2160p ProgramVideoResolution = "2160p"
	N240p  ProgramVideoResolution = "240p"
	N4320p ProgramVideoResolution = "4320p"
	N480i  ProgramVideoResolution = "480i"
	N480p  ProgramVideoResolution = "480p"
	N720p  ProgramVideoResolution = "720p"
)

// Defines values for ProgramVideoType.
const (
	H264  ProgramVideoType = "h.264"
	H265  ProgramVideoType = "h.265"
	Mpeg2 ProgramVideoType = "mpeg2"
)

// Defines values for StreamType.
const (
	LiveHLS        StreamType = "LiveHLS"
	LiveStream     StreamType = "LiveStream"
	RecordedHLS    StreamType = "RecordedHLS"
	RecordedStream StreamType = "RecordedStream"
)

// Defines values for VideoFileType.
const (
	Encoded VideoFileType = "encoded"
	Ts      VideoFileType = "ts"
)

// AddManualEncodeProgramOption エンコード手動追加時のオプション
type AddManualEncodeProgramOption struct {
	// Directory 親ディレクトリ以下のディレクトリ設定
	Directory *string `json:"directory,omitempty"`

	// IsSaveSameDirectory ソースビデオファイルと同じ場所に保存するか
	IsSaveSameDirectory *bool `json:"isSaveSameDirectory,omitempty"`

	// Mode エンコードプリセット名 config encode の name
	Mode string `json:"mode"`

	// ParentDir 親ディレクトリ名 config recorded の name, isSaveSameDirectory が false の場合は必須
	ParentDir *string `json:"parentDir,omitempty"`

	// RecordedId 録画済み番組 id
	RecordedId RecordedId `json:"recordedId"`

	// RemoveOriginal 元ファイルを削除するか
	RemoveOriginal bool `json:"removeOriginal"`

	// SourceVideoFileId ビデオファイル id
	SourceVideoFileId VideoFileId `json:"sourceVideoFileId"`
}

// AddRecordedTagOption 録画タグ追加プション
type AddRecordedTagOption struct {
	// Color 色
	Color string `json:"color"`

	// Name タグ名
	Name string `json:"name"`
}

// AddRuleOption ルール追加プション
type AddRuleOption struct {
	// EncodeOption 予約エンコードオプション
	EncodeOption *ReserveEncodedOption `json:"encodeOption,omitempty"`

	// IsTimeSpecification 時刻指定予約か
	IsTimeSpecification bool `json:"isTimeSpecification"`

	// ReserveOption ルール予約オプション
	ReserveOption RuleReserveOption `json:"reserveOption"`

	// SaveOption 予約保存オプション
	SaveOption *ReserveSaveOption `json:"saveOption,omitempty"`

	// SearchOption ルール検索オプション
	SearchOption RuleSearchOption `json:"searchOption"`
}

// AddedEncode エンコード追加成功応答データ
type AddedEncode struct {
	// EncodeId エンコード id
	EncodeId EncodeId `json:"encodeId"`
}

// AddedRecordedTag タグ追加成功応答データ
type AddedRecordedTag struct {
	// TagId 録画 tag id
	TagId RecordedTagId `json:"tagId"`
}

// AddedReserve 予約成功応答データ
type AddedReserve struct {
	// ReserveId 予約 id
	ReserveId ReserveId `json:"reserveId"`
}

// AddedRule ルール追加成功応答データ
type AddedRule struct {
	// RuleId ルール id
	RuleId RuleId `json:"ruleId"`
}

// ChannelId 放送局 id
type ChannelId = int

// ChannelItem チャンネル情報
type ChannelItem struct {
	Channel string `json:"channel"`

	// ChannelType 放送波タイプ
	ChannelType ChannelType `json:"channelType"`

	// HalfWidthName 放送局名(半角)
	HalfWidthName string `json:"halfWidthName"`

	// HasLogoData ロゴデータを持っているか
	HasLogoData bool `json:"hasLogoData"`

	// Id 放送局 id
	Id ChannelId `json:"id"`

	// Name 放送局名
	Name string `json:"name"`

	// NetworkId network id
	NetworkId NetworkId `json:"networkId"`

	// ServiceId service id
	ServiceId ServiceId `json:"serviceId"`
}

// ChannelItems defines model for ChannelItems.
type ChannelItems = []ChannelItem

// ChannelType 放送波タイプ
type ChannelType string

// Config コンフィグ
type Config struct {
	// Broadcast 有効な放送波情報
	Broadcast struct {
		BS  bool `json:"BS"`
		CS  bool `json:"CS"`
		GR  bool `json:"GR"`
		SKY bool `json:"SKY"`
	} `json:"broadcast"`

	// Encode エンコードモード
	Encode []string `json:"encode"`

	// IsEnableEncodedRecordedStream 録画済みのエンコード済みファイルのストリーミングが有効か
	IsEnableEncodedRecordedStream bool `json:"isEnableEncodedRecordedStream"`

	// IsEnableLiveStream ライブ視聴が有効か
	IsEnableLiveStream bool `json:"isEnableLiveStream"`

	// IsEnableTSRecordedStream 録画済みの TS ファイルのストリーミングが有効か
	IsEnableTSRecordedStream bool `json:"isEnableTSRecordedStream"`

	// KodiHosts kodi hosts
	KodiHosts *[]string `json:"kodiHosts,omitempty"`

	// Recorded 指定可能な録画ディレクトリ名
	Recorded []string `json:"recorded"`

	// SocketIOPort socket.io 通信で使用するポート
	SocketIOPort int `json:"socketIOPort"`

	// StreamConfig ストリーミング設定
	StreamConfig *struct {
		// Live ライブストリーミング設定
		Live *struct {
			// Hls ライブ HLS ストリーミング設定
			Hls *[]string `json:"hls,omitempty"`

			// M2ts ライブ M2TS ストリーミング設定
			M2ts *[]M2TSStreamParam `json:"m2ts,omitempty"`

			// M2tsll ライブ M2TS Low Latency (mpegts.js 用) ストリーミング設定
			M2tsll *[]string `json:"m2tsll,omitempty"`

			// Mp4 ライブ MP4 ストリーミング設定
			Mp4 *[]string `json:"mp4,omitempty"`

			// Webm ライブ WebM ストリーミング設定
			Webm *[]string `json:"webm,omitempty"`
		} `json:"live,omitempty"`

		// Recorded 録画済みストリーミング設定
		Recorded *struct {
			// Encoded 録画エンコード済みファイルのストリーミング設定
			Encoded *struct {
				// Hls 録画エンコード済みファイルの HLS ストリーミング設定
				Hls *[]string `json:"hls,omitempty"`

				// Mp4 録画エンコード済みファイルの MP4 ストリーミング設定
				Mp4 *[]string `json:"mp4,omitempty"`

				// Webm 録画エンコード済みファイルの WebM ストリーミング設定
				Webm *[]string `json:"webm,omitempty"`
			} `json:"encoded,omitempty"`

			// Ts 録画済み TS ファイルのストリーミング設定
			Ts *struct {
				// Hls 録画済み TS ファイルの HLS ストリーミング設定
				Hls *[]string `json:"hls,omitempty"`

				// Mp4 録画済み TS ファイルの MP4 ストリーミング設定
				Mp4 *[]string `json:"mp4,omitempty"`

				// Webm 録画済み TS ファイルの WebM ストリーミング設定
				Webm *[]string `json:"webm,omitempty"`
			} `json:"ts,omitempty"`
		} `json:"recorded,omitempty"`
	} `json:"streamConfig,omitempty"`

	// Urlscheme URL Scheme 情報
	Urlscheme struct {
		// Download URL Scheme
		Download URLSchemeInfo `json:"download"`

		// M2ts URL Scheme
		M2ts URLSchemeInfo `json:"m2ts"`

		// Video URL Scheme
		Video URLSchemeInfo `json:"video"`
	} `json:"urlscheme"`
}

// CreateNewRecordedOption 新規追加する録画番組情報
type CreateNewRecordedOption struct {
	// ChannelId 放送局 id
	ChannelId ChannelId `json:"channelId"`

	// Description 番組詳細
	Description *string `json:"description,omitempty"`

	// EndAt 時刻 (ms)
	EndAt UnixtimeMS `json:"endAt"`

	// Extended 番組拡張
	Extended *string `json:"extended,omitempty"`

	// Genre1 ジャンル
	Genre1 *ProgramGenreLv1 `json:"genre1,omitempty"`

	// Genre2 ジャンル
	Genre2 *ProgramGenreLv1 `json:"genre2,omitempty"`

	// Genre3 ジャンル
	Genre3 *ProgramGenreLv1 `json:"genre3,omitempty"`

	// Name 番組名
	Name string `json:"name"`

	// RuleId ルール id
	RuleId *RuleId `json:"ruleId,omitempty"`

	// StartAt 時刻 (ms)
	StartAt UnixtimeMS `json:"startAt"`

	// SubGenre1 サブジャンル
	SubGenre1 *ProgramGenreLv2 `json:"subGenre1,omitempty"`

	// SubGenre2 サブジャンル
	SubGenre2 *ProgramGenreLv2 `json:"subGenre2,omitempty"`

	// SubGenre3 サブジャンル
	SubGenre3 *ProgramGenreLv2 `json:"subGenre3,omitempty"`
}

// CreatedNewRecorded 録画番組情報の新規作成成功応答データ
type CreatedNewRecorded struct {
	// RecordedId 録画済み番組 id
	RecordedId RecordedId `json:"recordedId"`
}

// DropLogFile ドロップログファイル情報
type DropLogFile struct {
	// DropCnt ドロップカウント
	DropCnt int `json:"dropCnt"`

	// ErrorCnt エラーカウント
	ErrorCnt int `json:"errorCnt"`

	// Id ドロップログファイル id
	Id DropLogFileId `json:"id"`

	// ScramblingCnt スクランブルカウント
	ScramblingCnt int `json:"scramblingCnt"`
}

// DropLogFileId ドロップログファイル id
type DropLogFileId = int

// EditManualReserveOption 手動予約編集オプション
type EditManualReserveOption struct {
	// AllowEndLack 末尾切れを許すか
	AllowEndLack bool `json:"allowEndLack"`

	// EncodeOption 予約エンコードオプション
	EncodeOption *ReserveEncodedOption `json:"encodeOption,omitempty"`

	// SaveOption 予約保存オプション
	SaveOption *ReserveSaveOption `json:"saveOption,omitempty"`
	Tags       *[]RecordedTagId   `json:"tags,omitempty"`
}

// EncodeId エンコード id
type EncodeId = int

// EncodeInfo エンコード情報
type EncodeInfo struct {
	RunningItems []EncodeProgramItem `json:"runningItems"`
	WaitItems    []EncodeProgramItem `json:"waitItems"`
}

// EncodeProgramItem エンコードプログラム情報
type EncodeProgramItem struct {
	// Id エンコード id
	Id EncodeId `json:"id"`

	// Log ログ
	Log *string `json:"log,omitempty"`

	// Mode エンコード名
	Mode string `json:"mode"`

	// Percent 進捗
	Percent *float32 `json:"percent,omitempty"`

	// Recorded 録画番組情報
	Recorded RecordedItem `json:"recorded"`
}

// Error defines model for Error.
type Error struct {
	// Code HTTPステータスコード
	Code int32 `json:"code"`

	// Errors Error
	Errors *string `json:"errors,omitempty"`

	// Message エラーメッセージ
	Message string `json:"message"`
}

// Genre ジャンル設定
type Genre struct {
	// Genre ジャンル
	Genre ProgramGenreLv1 `json:"genre"`

	// SubGenre サブジャンル
	SubGenre *ProgramGenreLv2 `json:"subGenre,omitempty"`
}

// M2TSStreamParam M2TS形式ストリーミングパラメータ
type M2TSStreamParam struct {
	// IsUnconverted 無変換か
	IsUnconverted bool `json:"isUnconverted"`

	// Name 表示名
	Name string `json:"name"`
}

// ManualReserveOption 手動予約編集オプション
type ManualReserveOption = EditManualReserveOption

// NetworkId network id
type NetworkId = int

// ProgramAudioSamplingRate 番組オーディオサンプリングレート
type ProgramAudioSamplingRate int

// ProgramGenreLv1 ジャンル
type ProgramGenreLv1 = int

// ProgramGenreLv2 サブジャンル
type ProgramGenreLv2 = int

// ProgramId program id
type ProgramId = int

// ProgramVideoResolution 番組ビデオ解像度
type ProgramVideoResolution string

// ProgramVideoType 番組ビデオコーデック
type ProgramVideoType string

// RecordedChannelListItem recorded が持つ channelId のリスト
type RecordedChannelListItem struct {
	// ChannelId 放送局 id
	ChannelId ChannelId `json:"channelId"`

	// Cnt 録画数
	Cnt int `json:"cnt"`
}

// RecordedGenreListItem recorded が持つ genre のリスト
type RecordedGenreListItem struct {
	// Cnt 録画数
	Cnt int `json:"cnt"`

	// Genre ジャンル
	Genre ProgramGenreLv1 `json:"genre"`
}

// RecordedId 録画済み番組 id
type RecordedId = int

// RecordedItem 録画番組情報
type RecordedItem struct {
	AudioComponentType *int `json:"audioComponentType,omitempty"`

	// AudioSamplingRate 番組オーディオサンプリングレート
	AudioSamplingRate *ProgramAudioSamplingRate `json:"audioSamplingRate,omitempty"`

	// ChannelId 放送局 id
	ChannelId *ChannelId `json:"channelId,omitempty"`

	// Description 番組詳細
	Description *string `json:"description,omitempty"`

	// DropLog ドロップログファイル情報
	DropLog *DropLogFile `json:"dropLog,omitempty"`

	// EndAt 時刻 (ms)
	EndAt UnixtimeMS `json:"endAt"`

	// Extended 番組拡張
	Extended *string `json:"extended,omitempty"`

	// Genre1 ジャンル
	Genre1 *ProgramGenreLv1 `json:"genre1,omitempty"`

	// Genre2 ジャンル
	Genre2 *ProgramGenreLv1 `json:"genre2,omitempty"`

	// Genre3 ジャンル
	Genre3 *ProgramGenreLv1 `json:"genre3,omitempty"`

	// Id 録画済み番組 id
	Id RecordedId `json:"id"`

	// IsEncoding エンコード中か
	IsEncoding bool `json:"isEncoding"`

	// IsProtected 自動録画削除対象外か
	IsProtected bool `json:"isProtected"`

	// IsRecording 録画中か
	IsRecording bool `json:"isRecording"`

	// Name 番組名
	Name string `json:"name"`

	// ProgramId program id
	ProgramId *ProgramId `json:"programId,omitempty"`

	// RawExtended 番組拡張 (Mirakurun の extended)
	RawExtended *map[string]interface{} `json:"rawExtended,omitempty"`

	// RuleId ルール id
	RuleId *RuleId `json:"ruleId,omitempty"`

	// StartAt 時刻 (ms)
	StartAt UnixtimeMS `json:"startAt"`

	// SubGenre1 サブジャンル
	SubGenre1 *ProgramGenreLv2 `json:"subGenre1,omitempty"`

	// SubGenre2 サブジャンル
	SubGenre2 *ProgramGenreLv2 `json:"subGenre2,omitempty"`

	// SubGenre3 サブジャンル
	SubGenre3          *ProgramGenreLv2 `json:"subGenre3,omitempty"`
	Tags               *[]RecordedTag   `json:"tags,omitempty"`
	Thumbnails         *[]ThumbnailId   `json:"thumbnails,omitempty"`
	VideoComponentType *int             `json:"videoComponentType,omitempty"`
	VideoFiles         *[]VideoFile     `json:"videoFiles,omitempty"`

	// VideoResolution 番組ビデオ解像度
	VideoResolution    *ProgramVideoResolution `json:"videoResolution,omitempty"`
	VideoStreamContent *int                    `json:"videoStreamContent,omitempty"`

	// VideoType 番組ビデオコーデック
	VideoType *ProgramVideoType `json:"videoType,omitempty"`
}

// RecordedSearchOptions recorded が持つ検索オプション情報
type RecordedSearchOptions struct {
	Channels []RecordedChannelListItem `json:"channels"`
	Genres   []RecordedGenreListItem   `json:"genres"`
}

// RecordedTag タグ情報
type RecordedTag struct {
	// Color 色
	Color string `json:"color"`

	// Id 録画 tag id
	Id RecordedTagId `json:"id"`

	// Name タグ名
	Name string `json:"name"`
}

// RecordedTagId 録画 tag id
type RecordedTagId = int

// RecordedTags 録画タグ情報
type RecordedTags struct {
	Tags []RecordedTag `json:"tags"`

	// Total 予約総件数
	Total int `json:"total"`
}

// Records 録画情報
type Records struct {
	Records []RecordedItem `json:"records"`

	// Total 録画総件数
	Total int `json:"total"`
}

// RelateRecordedTagOption 録画番組とタグの関連付けオプション
type RelateRecordedTagOption struct {
	// RecordedId 録画済み番組 id
	RecordedId RecordedId `json:"recordedId"`
}

// ReserveCnts 予約カウント
type ReserveCnts struct {
	// Conflicts 競合予約数
	Conflicts int `json:"conflicts"`

	// Normal 通常予約数
	Normal int `json:"normal"`

	// Overlaps 重複予約数
	Overlaps int `json:"overlaps"`

	// Skips 競合予約数
	Skips int `json:"skips"`
}

// ReserveEncodedOption 予約エンコードオプション
type ReserveEncodedOption struct {
	// Directory1 エンコードモード1ディレクトリ
	Directory1 *string `json:"directory1,omitempty"`

	// Directory2 エンコードモード2ディレクトリ
	Directory2 *string `json:"directory2,omitempty"`

	// Directory3 エンコードモード3ディレクトリ
	Directory3 *string `json:"directory3,omitempty"`

	// EncodeParentDirectoryName1 エンコードモード1親ディレクトリ
	EncodeParentDirectoryName1 *string `json:"encodeParentDirectoryName1,omitempty"`

	// EncodeParentDirectoryName2 エンコードモード2親ディレクトリ
	EncodeParentDirectoryName2 *string `json:"encodeParentDirectoryName2,omitempty"`

	// EncodeParentDirectoryName3 エンコードモード3親ディレクトリ
	EncodeParentDirectoryName3 *string `json:"encodeParentDirectoryName3,omitempty"`

	// IsDeleteOriginalAfterEncode エンコード後に ts を削除するか
	IsDeleteOriginalAfterEncode bool `json:"isDeleteOriginalAfterEncode"`

	// Mode1 エンコードモード1
	Mode1 *string `json:"mode1,omitempty"`

	// Mode2 エンコードモード2
	Mode2 *string `json:"mode2,omitempty"`

	// Mode3 エンコードモード3
	Mode3 *string `json:"mode3,omitempty"`
}

// ReserveId 予約 id
type ReserveId = int

// ReserveItem 予約番組情報
type ReserveItem struct {
	AllowEndLack       bool `json:"allowEndLack"`
	AudioComponentType *int `json:"audioComponentType,omitempty"`

	// AudioSamplingRate 番組オーディオサンプリングレート
	AudioSamplingRate *ProgramAudioSamplingRate `json:"audioSamplingRate,omitempty"`

	// ChannelId 放送局 id
	ChannelId                  ChannelId `json:"channelId"`
	Description                *string   `json:"description,omitempty"`
	Directory                  *string   `json:"directory,omitempty"`
	EncodeDirectory1           *string   `json:"encodeDirectory1,omitempty"`
	EncodeDirectory2           *string   `json:"encodeDirectory2,omitempty"`
	EncodeDirectory3           *int      `json:"encodeDirectory3,omitempty"`
	EncodeMode1                *int      `json:"encodeMode1,omitempty"`
	EncodeMode2                *int      `json:"encodeMode2,omitempty"`
	EncodeMode3                *int      `json:"encodeMode3,omitempty"`
	EncodeParentDirectoryName1 *string   `json:"encodeParentDirectoryName1,omitempty"`
	EncodeParentDirectoryName2 *string   `json:"encodeParentDirectoryName2,omitempty"`
	EncodeParentDirectoryName3 *string   `json:"encodeParentDirectoryName3,omitempty"`

	// EndAt 時刻 (ms)
	EndAt    UnixtimeMS `json:"endAt"`
	Extended *string    `json:"extended,omitempty"`

	// Genre1 ジャンル
	Genre1 *ProgramGenreLv1 `json:"genre1,omitempty"`

	// Genre2 ジャンル
	Genre2 *ProgramGenreLv1 `json:"genre2,omitempty"`

	// Genre3 ジャンル
	Genre3 *ProgramGenreLv1 `json:"genre3,omitempty"`

	// Id 予約 id
	Id                          ReserveId `json:"id"`
	IsConflict                  bool      `json:"isConflict"`
	IsDeleteOriginalAfterEncode bool      `json:"isDeleteOriginalAfterEncode"`
	IsOverlap                   bool      `json:"isOverlap"`
	IsSkip                      bool      `json:"isSkip"`
	IsTimeSpecified             bool      `json:"isTimeSpecified"`
	Name                        string    `json:"name"`
	ParentDirectoryName         *string   `json:"parentDirectoryName,omitempty"`

	// ProgramId program id
	ProgramId      *ProgramId              `json:"programId,omitempty"`
	RawExtended    *map[string]interface{} `json:"rawExtended,omitempty"`
	RecordedFormat *string                 `json:"recordedFormat,omitempty"`

	// RuleId ルール id
	RuleId *RuleId `json:"ruleId,omitempty"`

	// StartAt 時刻 (ms)
	StartAt UnixtimeMS `json:"startAt"`

	// SubGenre1 サブジャンル
	SubGenre1 *ProgramGenreLv2 `json:"subGenre1,omitempty"`

	// SubGenre2 サブジャンル
	SubGenre2 *ProgramGenreLv2 `json:"subGenre2,omitempty"`

	// SubGenre3 サブジャンル
	SubGenre3          *ProgramGenreLv2 `json:"subGenre3,omitempty"`
	Tags               *[]RecordedTagId `json:"tags,omitempty"`
	VideoComponentType *int             `json:"videoComponentType,omitempty"`

	// VideoResolution 番組ビデオ解像度
	VideoResolution    *ProgramVideoResolution `json:"videoResolution,omitempty"`
	VideoStreamContent *int                    `json:"videoStreamContent,omitempty"`

	// VideoType 番組ビデオコーデック
	VideoType *ProgramVideoType `json:"videoType,omitempty"`
}

// ReserveListItem 予約リストitem
type ReserveListItem struct {
	// ProgramId program id
	ProgramId *ProgramId `json:"programId,omitempty"`

	// ReserveId 予約 id
	ReserveId ReserveId `json:"reserveId"`

	// RuleId ルール id
	RuleId *RuleId `json:"ruleId,omitempty"`
}

// ReserveLists 予約, 除外, 重複, 競合の reserveId のリスト
type ReserveLists struct {
	// Conflicts 予約リストitem
	Conflicts ReserveListItem `json:"conflicts"`

	// Normal 予約リストitem
	Normal ReserveListItem `json:"normal"`

	// Overlaps 予約リストitem
	Overlaps ReserveListItem `json:"overlaps"`

	// Skips 予約リストitem
	Skips ReserveListItem `json:"skips"`
}

// ReserveSaveOption 予約保存オプション
type ReserveSaveOption struct {
	// Directory 保存ディレクトリ
	Directory *string `json:"directory,omitempty"`

	// ParentDirectoryName 親保存ディレクトリ
	ParentDirectoryName *string `json:"parentDirectoryName,omitempty"`

	// RecordedFormat ファイル名フォーマット
	RecordedFormat *string `json:"recordedFormat,omitempty"`
}

// Reserves 予約情報
type Reserves struct {
	Reserves []ReserveItem `json:"reserves"`

	// Total 予約総件数
	Total int `json:"total"`
}

// Rule defines model for Rule.
type Rule struct {
	// EncodeOption 予約エンコードオプション
	EncodeOption *ReserveEncodedOption `json:"encodeOption,omitempty"`

	// Id ルール id
	Id RuleId `json:"id"`

	// IsTimeSpecification 時刻指定予約か
	IsTimeSpecification bool `json:"isTimeSpecification"`

	// ReserveOption ルール予約オプション
	ReserveOption RuleReserveOption `json:"reserveOption"`

	// ReservesCnt 予約件数
	ReservesCnt *int `json:"reservesCnt,omitempty"`

	// SaveOption 予約保存オプション
	SaveOption *ReserveSaveOption `json:"saveOption,omitempty"`

	// SearchOption ルール検索オプション
	SearchOption RuleSearchOption `json:"searchOption"`
}

// RuleId ルール id
type RuleId = int

// RuleKeywordInfo ルールキーワード検索結果
type RuleKeywordInfo struct {
	Items []RuleKeywordItem `json:"items"`
}

// RuleKeywordItem defines model for RuleKeywordItem.
type RuleKeywordItem struct {
	// Id ルール id
	Id      RuleId `json:"id"`
	Keyword string `json:"keyword"`
}

// RuleReserveOption ルール予約オプション
type RuleReserveOption struct {
	// AllowEndLack 末尾切れを許可するか
	AllowEndLack bool `json:"allowEndLack"`

	// AvoidDuplicate 録画済みの重複番組を排除するか
	AvoidDuplicate bool `json:"avoidDuplicate"`

	// Enable ルールが有効か
	Enable bool `json:"enable"`

	// PeriodToAvoidDuplicate 重複を避ける期間
	PeriodToAvoidDuplicate *int             `json:"periodToAvoidDuplicate,omitempty"`
	Tags                   *[]RecordedTagId `json:"tags,omitempty"`
}

// RuleSearchOption ルール検索オプション
type RuleSearchOption struct {
	// BS BS
	BS *bool `json:"BS,omitempty"`

	// CS CS
	CS *bool `json:"CS,omitempty"`

	// GR GR
	GR *bool `json:"GR,omitempty"`

	// SKY SKY
	SKY *bool `json:"SKY,omitempty"`

	// ChannelIds 放送局
	ChannelIds *[]ChannelId `json:"channelIds,omitempty"`

	// Description 概要 (検索キーワード)
	Description *bool `json:"description,omitempty"`

	// DurationMax 番組最大時間 (分)
	DurationMax *int `json:"durationMax,omitempty"`

	// DurationMin 番組最小時間 (分)
	DurationMin *int `json:"durationMin,omitempty"`

	// Extended 詳細 (検索キーワード)
	Extended *bool `json:"extended,omitempty"`

	// Genres ジャンル
	Genres *[]Genre `json:"genres,omitempty"`

	// IgnoreDescription 概要 (除外検索キーワード)
	IgnoreDescription *bool `json:"ignoreDescription,omitempty"`

	// IgnoreExtended 詳細 (除外検索キーワード)
	IgnoreExtended *bool `json:"ignoreExtended,omitempty"`

	// IgnoreKeyCS 大文字小文字区別有効化 (除外検索キーワード)
	IgnoreKeyCS *bool `json:"ignoreKeyCS,omitempty"`

	// IgnoreKeyRegExp 正規表現 (除外検索キーワード)
	IgnoreKeyRegExp *bool `json:"ignoreKeyRegExp,omitempty"`

	// IgnoreKeyword 除外検索キーワード
	IgnoreKeyword *string `json:"ignoreKeyword,omitempty"`

	// IgnoreName 番組名 (除外検索キーワード)
	IgnoreName *bool `json:"ignoreName,omitempty"`

	// IsFree 無料放送か
	IsFree *bool `json:"isFree,omitempty"`

	// KeyCS 大文字小文字区別有効化 (検索キーワード)
	KeyCS *bool `json:"keyCS,omitempty"`

	// KeyRegExp 正規表現 (検索キーワード)
	KeyRegExp *bool `json:"keyRegExp,omitempty"`

	// Keyword 検索キーワード
	Keyword *string `json:"keyword,omitempty"`

	// Name 番組名 (検索キーワード)
	Name *bool `json:"name,omitempty"`

	// SearchPeriods 検索対象期間
	SearchPeriods *[]SearchPeriod `json:"searchPeriods,omitempty"`

	// Times 時刻範囲
	Times *[]SearchTime `json:"times,omitempty"`
}

// Rules ルール情報
type Rules struct {
	Rules []Rule `json:"rules"`

	// Total ルール総件数
	Total int `json:"total"`
}

// Schedule 番組表データ
type Schedule struct {
	// Channel 番組表の放送局データ
	Channel  ScheduleChannleItem  `json:"channel"`
	Programs ScheduleProgramItems `json:"programs"`
}

// ScheduleChannleItem 番組表の放送局データ
type ScheduleChannleItem struct {
	// ChannelType 放送波タイプ
	ChannelType ChannelType `json:"channelType"`

	// HasLogoData ロゴデータを持っているか
	HasLogoData bool `json:"hasLogoData"`

	// Id 放送局 id
	Id ChannelId `json:"id"`

	// Name 放送局名
	Name string `json:"name"`

	// NetworkId network id
	NetworkId NetworkId `json:"networkId"`

	// RemoteControlKeyId リモコン番号
	RemoteControlKeyId *int `json:"remoteControlKeyId,omitempty"`

	// ServiceId service id
	ServiceId ServiceId `json:"serviceId"`
}

// ScheduleProgramItem 番組表の番組データ
type ScheduleProgramItem struct {
	AudioComponentType *int `json:"audioComponentType,omitempty"`

	// AudioSamplingRate 番組オーディオサンプリングレート
	AudioSamplingRate *ProgramAudioSamplingRate `json:"audioSamplingRate,omitempty"`

	// ChannelId 放送局 id
	ChannelId ChannelId `json:"channelId"`

	// Description 番組詳細
	Description *string `json:"description,omitempty"`

	// EndAt 時刻 (ms)
	EndAt UnixtimeMS `json:"endAt"`

	// Extended 番組拡張
	Extended *string `json:"extended,omitempty"`

	// Genre1 ジャンル
	Genre1 *ProgramGenreLv1 `json:"genre1,omitempty"`

	// Genre2 ジャンル
	Genre2 *ProgramGenreLv1 `json:"genre2,omitempty"`

	// Genre3 ジャンル
	Genre3 *ProgramGenreLv1 `json:"genre3,omitempty"`

	// Id program id
	Id ProgramId `json:"id"`

	// IsFree 無料放送か
	IsFree bool `json:"isFree"`

	// Name 番組名
	Name string `json:"name"`

	// RawExtended 番組拡張 (Mirakurun の extended)
	RawExtended *map[string]interface{} `json:"rawExtended,omitempty"`

	// StartAt 時刻 (ms)
	StartAt UnixtimeMS `json:"startAt"`

	// SubGenre1 サブジャンル
	SubGenre1 *ProgramGenreLv2 `json:"subGenre1,omitempty"`

	// SubGenre2 サブジャンル
	SubGenre2 *ProgramGenreLv2 `json:"subGenre2,omitempty"`

	// SubGenre3 サブジャンル
	SubGenre3          *ProgramGenreLv2 `json:"subGenre3,omitempty"`
	VideoComponentType *int             `json:"videoComponentType,omitempty"`

	// VideoResolution 番組ビデオ解像度
	VideoResolution    *ProgramVideoResolution `json:"videoResolution,omitempty"`
	VideoStreamContent *int                    `json:"videoStreamContent,omitempty"`

	// VideoType 番組ビデオコーデック
	VideoType *ProgramVideoType `json:"videoType,omitempty"`
}

// ScheduleProgramItems defines model for ScheduleProgramItems.
type ScheduleProgramItems = []ScheduleProgramItem

// ScheduleSearchOption 番組検索オプション
type ScheduleSearchOption struct {
	// IsHalfWidth 半角文字で取得するか
	IsHalfWidth bool `json:"isHalfWidth"`

	// Limit 検索結果取得最大件数
	Limit *float32 `json:"limit,omitempty"`

	// Option ルール検索オプション
	Option RuleSearchOption `json:"option"`
}

// Schedules defines model for Schedules.
type Schedules = []Schedule

// SearchPeriod 検索対象期間オプション
type SearchPeriod struct {
	// EndAt 時刻 (ms)
	EndAt UnixtimeMS `json:"endAt"`

	// StartAt 時刻 (ms)
	StartAt UnixtimeMS `json:"startAt"`
}

// SearchTime 時刻範囲指定オプション
type SearchTime struct {
	// Range 開始時刻からの時刻範囲(時) 1 - 23, 時刻予約の場合は秒で時間の長さを指定する 1 ~ 60 * 50 * 24 秒
	Range *int `json:"range,omitempty"`

	// Start 開始時刻 1 - 23, 時刻予約の場合は 0 時を 0 とした 0 ~ (60 * 50 * 24) - 1 秒までの開始時刻を指定する
	Start *int `json:"start,omitempty"`

	// Week 曜日指定 0x01, 0x02, 0x04, 0x08, 0x10, 0x20 ,0x40 が日〜土に対応するので and 演算で曜日を指定する
	Week int `json:"week"`
}

// SendVideoLinkToKodiOption kodiへビデオリンクを送信するときのオプション
type SendVideoLinkToKodiOption struct {
	// KodiName config の kodi の name
	KodiName string `json:"kodiName"`
}

// ServiceId service id
type ServiceId = int

// StartStreamInfo ストリーム開始情報
type StartStreamInfo struct {
	// StreamId ストリーム id
	StreamId StreamId `json:"streamId"`
}

// StorageInfo ストレージ情報
type StorageInfo struct {
	Items []StorageItem `json:"items"`
}

// StorageItem ストレージ使用状況
type StorageItem struct {
	// Available 空き容量 (byte)
	Available int `json:"available"`

	// Name ディスク名
	Name string `json:"name"`

	// Total 総容量 (byte)
	Total int `json:"total"`

	// Used 使用量 (byte)
	Used int `json:"used"`
}

// StreamId ストリーム id
type StreamId = int

// StreamInfo defines model for StreamInfo.
type StreamInfo struct {
	Items []StreamInfoItem `json:"items"`
}

// StreamInfoItem ストリーム情報
type StreamInfoItem struct {
	// ChannelId 放送局 id
	ChannelId ChannelId `json:"channelId"`

	// Description ストリーミング番組詳細
	Description *string `json:"description,omitempty"`

	// EndAt 時刻 (ms)
	EndAt UnixtimeMS `json:"endAt"`

	// Extended ストリーミング番組拡張
	Extended *string `json:"extended,omitempty"`

	// IsEnable 放送波が有効か (HLS 形式の場合有効)
	IsEnable bool `json:"isEnable"`

	// Mode ストリーミング設定
	Mode float32 `json:"mode"`

	// Name ストリーミング番組名
	Name string `json:"name"`

	// RecordedId 録画済み番組 id
	RecordedId *RecordedId `json:"recordedId,omitempty"`

	// StartAt 時刻 (ms)
	StartAt UnixtimeMS `json:"startAt"`

	// StreamId ストリーム id
	StreamId StreamId `json:"streamId"`

	// Type ストリームの種類
	Type StreamType `json:"type"`

	// VideoFileId ビデオファイル id
	VideoFileId *VideoFileId `json:"videoFileId,omitempty"`
}

// StreamType ストリームの種類
type StreamType string

// ThumbnailId サムネイル id
type ThumbnailId = int

// URLSchemeInfo URL Scheme
type URLSchemeInfo struct {
	Android *string `json:"android,omitempty"`
	Ios     *string `json:"ios,omitempty"`
	Mac     *string `json:"mac,omitempty"`
	Win     *string `json:"win,omitempty"`
}

// UnixtimeMS 時刻 (ms)
type UnixtimeMS = int

// UploadVideoFileOption ビデオファイルをアップロード
type UploadVideoFileOption struct {
	File openapi_types.File `json:"file"`

	// FileType ビデオファイル形式
	FileType VideoFileType `json:"fileType"`

	// ParentDirectoryName 親保存ディレクトリ
	ParentDirectoryName string `json:"parentDirectoryName"`

	// RecordedId 録画済み番組 id
	RecordedId RecordedId `json:"recordedId"`

	// SubDirectory 保存ディレクトリ
	SubDirectory *string `json:"subDirectory,omitempty"`

	// ViewName 表示名
	ViewName string `json:"viewName"`
}

// Version バージョン情報
type Version struct {
	Version string `json:"version"`
}

// VideoFile ビデオファイル情報
type VideoFile struct {
	// Filename ビデオファイル名
	Filename *string `json:"filename,omitempty"`

	// Id ビデオファイル id
	Id VideoFileId `json:"id"`

	// Name ビデオ名 (Web上の表示名)
	Name string `json:"name"`

	// Size ファイルサイズ
	Size int `json:"size"`

	// Type ビデオファイル形式
	Type VideoFileType `json:"type"`
}

// VideoFileDuration ビデオファイルの長さ
type VideoFileDuration struct {
	// Duration 動画長(秒)
	Duration float32 `json:"duration"`
}

// VideoFileId ビデオファイル id
type VideoFileId = int

// VideoFileType ビデオファイル形式
type VideoFileType string

// AddtionTime 時刻 (ms)
type AddtionTime = UnixtimeMS

// Days defines model for Days.
type Days = int

// EndAt 時刻 (ms)
type EndAt = UnixtimeMS

// GetReserveType defines model for GetReserveType.
type GetReserveType = interface{}

// IPTVDays defines model for IPTVDays.
type IPTVDays = int

// IPTVIsHalfWidth defines model for IPTVIsHalfWidth.
type IPTVIsHalfWidth = bool

// IsDownload defines model for IsDownload.
type IsDownload = bool

// IsFreeProgram defines model for IsFreeProgram.
type IsFreeProgram = bool

// IsHalfWidth defines model for IsHalfWidth.
type IsHalfWidth = bool

// IsReverse defines model for IsReverse.
type IsReverse = bool

// Limit defines model for Limit.
type Limit = int

// LogFileMaxSize defines model for LogFileMaxSize.
type LogFileMaxSize = int

// NeedsRawExtended defines model for NeedsRawExtended.
type NeedsRawExtended = bool

// Offset defines model for Offset.
type Offset = int

// PathChannelId 放送局 id
type PathChannelId = ChannelId

// PathDropLogFileId defines model for PathDropLogFileId.
type PathDropLogFileId = int

// PathEncodeId defines model for PathEncodeId.
type PathEncodeId = int

// PathProgramId program id
type PathProgramId = ProgramId

// PathRecordedId defines model for PathRecordedId.
type PathRecordedId = int

// PathRecordedTagId defines model for PathRecordedTagId.
type PathRecordedTagId = int

// PathReserveId defines model for PathReserveId.
type PathReserveId = int

// PathRuleId defines model for PathRuleId.
type PathRuleId = int

// PathStreamId ストリーム id
type PathStreamId = StreamId

// PathThumbnailId defines model for PathThumbnailId.
type PathThumbnailId = int

// PathVideoFileId defines model for PathVideoFileId.
type PathVideoFileId = int

// QueryChannelId 放送局 id
type QueryChannelId = ChannelId

// QueryExcludeRecordedTagId defines model for QueryExcludeRecordedTagId.
type QueryExcludeRecordedTagId = []string

// QueryHasOriginalFile defines model for QueryHasOriginalFile.
type QueryHasOriginalFile = bool

// QueryKeyword defines model for QueryKeyword.
type QueryKeyword = string

// QueryName defines model for QueryName.
type QueryName = string

// QueryProgramGenre ジャンル
type QueryProgramGenre = ProgramGenreLv1

// QueryRecordedId 録画済み番組 id
type QueryRecordedId = RecordedId

// QueryRuleId ルール id
type QueryRuleId = RuleId

// StartAt 時刻 (ms)
type StartAt = UnixtimeMS

// StreamMode defines model for StreamMode.
type StreamMode = int

// StreamPlayPosition defines model for StreamPlayPosition.
type StreamPlayPosition = int

// RequiredBS defines model for requiredBS.
type RequiredBS = bool

// RequiredCS defines model for requiredCS.
type RequiredCS = bool

// RequiredGR defines model for requiredGR.
type RequiredGR = bool

// RequiredSKY defines model for requiredSKY.
type RequiredSKY = bool

// GetDropLogsDropLogFileIdParams defines parameters for GetDropLogsDropLogFileId.
type GetDropLogsDropLogFileIdParams struct {
	// Maxsize ファイル最大サイズ (kByte)
	Maxsize *LogFileMaxSize `form:"maxsize,omitempty" json:"maxsize,omitempty"`
}

// GetEncodeParams defines parameters for GetEncode.
type GetEncodeParams struct {
	// IsHalfWidth 半角文字で取得するか
	IsHalfWidth IsHalfWidth `form:"isHalfWidth" json:"isHalfWidth"`
}

// GetIptvChannelM3u8Params defines parameters for GetIptvChannelM3u8.
type GetIptvChannelM3u8Params struct {
	// IsHalfWidth 半角文字で取得するか
	IsHalfWidth *IPTVIsHalfWidth `form:"isHalfWidth,omitempty" json:"isHalfWidth,omitempty"`

	// Mode ストリーミング設定
	Mode StreamMode `form:"mode" json:"mode"`
}

// GetIptvEpgXmlParams defines parameters for GetIptvEpgXml.
type GetIptvEpgXmlParams struct {
	// IsHalfWidth 半角文字で取得するか
	IsHalfWidth *IPTVIsHalfWidth `form:"isHalfWidth,omitempty" json:"isHalfWidth,omitempty"`

	// Days 取得日数
	Days *IPTVDays `form:"days,omitempty" json:"days,omitempty"`
}

// GetRecordedParams defines parameters for GetRecorded.
type GetRecordedParams struct {
	// IsHalfWidth 半角文字で取得するか
	IsHalfWidth IsHalfWidth `form:"isHalfWidth" json:"isHalfWidth"`

	// Offset offset
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit limit
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// IsReverse 逆順で取得するか
	IsReverse *IsReverse `form:"isReverse,omitempty" json:"isReverse,omitempty"`

	// RuleId ルールid
	RuleId *QueryRuleId `form:"ruleId,omitempty" json:"ruleId,omitempty"`

	// ChannelId 放送局 id
	ChannelId *QueryChannelId `form:"channelId,omitempty" json:"channelId,omitempty"`

	// Genre ジャンル
	Genre *QueryProgramGenre `form:"genre,omitempty" json:"genre,omitempty"`

	// Keyword キーワード
	Keyword *QueryKeyword `form:"keyword,omitempty" json:"keyword,omitempty"`

	// HasOriginalFile オリジナルファイルを含むか
	HasOriginalFile *QueryHasOriginalFile `form:"hasOriginalFile,omitempty" json:"hasOriginalFile,omitempty"`
}

// GetRecordedRecordedIdParams defines parameters for GetRecordedRecordedId.
type GetRecordedRecordedIdParams struct {
	// IsHalfWidth 半角文字で取得するか
	IsHalfWidth IsHalfWidth `form:"isHalfWidth" json:"isHalfWidth"`
}

// GetRecordingParams defines parameters for GetRecording.
type GetRecordingParams struct {
	// Offset offset
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit limit
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// IsHalfWidth 半角文字で取得するか
	IsHalfWidth IsHalfWidth `form:"isHalfWidth" json:"isHalfWidth"`
}

// GetReservesParams defines parameters for GetReserves.
type GetReservesParams struct {
	// Offset offset
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit limit
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type 予約情報取得タイプ
	Type *GetReserveType `form:"type,omitempty" json:"type,omitempty"`

	// IsHalfWidth 半角文字で取得するか
	IsHalfWidth IsHalfWidth `form:"isHalfWidth" json:"isHalfWidth"`

	// RuleId ルールid
	RuleId *QueryRuleId `form:"ruleId,omitempty" json:"ruleId,omitempty"`
}

// GetReservesListsParams defines parameters for GetReservesLists.
type GetReservesListsParams struct {
	// StartAt 開始時刻
	StartAt StartAt `form:"startAt" json:"startAt"`

	// EndAt 終了時刻
	EndAt EndAt `form:"endAt" json:"endAt"`
}

// GetReservesReserveIdParams defines parameters for GetReservesReserveId.
type GetReservesReserveIdParams struct {
	// IsHalfWidth 半角文字で取得するか
	IsHalfWidth IsHalfWidth `form:"isHalfWidth" json:"isHalfWidth"`
}

// GetRulesParams defines parameters for GetRules.
type GetRulesParams struct {
	// Offset offset
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit limit
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type 予約情報取得タイプ
	Type *GetReserveType `form:"type,omitempty" json:"type,omitempty"`

	// Keyword キーワード
	Keyword *QueryKeyword `form:"keyword,omitempty" json:"keyword,omitempty"`
}

// GetRulesKeywordParams defines parameters for GetRulesKeyword.
type GetRulesKeywordParams struct {
	// Offset offset
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit limit
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Keyword キーワード
	Keyword *QueryKeyword `form:"keyword,omitempty" json:"keyword,omitempty"`
}

// GetSchedulesParams defines parameters for GetSchedules.
type GetSchedulesParams struct {
	// StartAt 開始時刻
	StartAt StartAt `form:"startAt" json:"startAt"`

	// EndAt 終了時刻
	EndAt EndAt `form:"endAt" json:"endAt"`

	// IsHalfWidth 半角文字で取得するか
	IsHalfWidth IsHalfWidth `form:"isHalfWidth" json:"isHalfWidth"`

	// NeedsRawExtended rawExtended が必要か
	NeedsRawExtended *NeedsRawExtended `form:"needsRawExtended,omitempty" json:"needsRawExtended,omitempty"`

	// IsFree 無料放送のみ取得するか (true: 無料放送, false: 有料放送, 無指定: 全て)
	IsFree *IsFreeProgram `form:"isFree,omitempty" json:"isFree,omitempty"`

	// GR GR
	GR RequiredGR `form:"GR" json:"GR"`

	// BS BS
	BS RequiredBS `form:"BS" json:"BS"`

	// CS CS
	CS RequiredCS `form:"CS" json:"CS"`

	// SKY SKY
	SKY RequiredSKY `form:"SKY" json:"SKY"`
}

// GetSchedulesBroadcastingParams defines parameters for GetSchedulesBroadcasting.
type GetSchedulesBroadcastingParams struct {
	// Time 追加時間 (ms)
	Time *AddtionTime `form:"time,omitempty" json:"time,omitempty"`

	// IsHalfWidth 半角文字で取得するか
	IsHalfWidth IsHalfWidth `form:"isHalfWidth" json:"isHalfWidth"`
}

// GetSchedulesDetailProgramIdParams defines parameters for GetSchedulesDetailProgramId.
type GetSchedulesDetailProgramIdParams struct {
	// IsHalfWidth 半角文字で取得するか
	IsHalfWidth IsHalfWidth `form:"isHalfWidth" json:"isHalfWidth"`
}

// GetSchedulesChannelIdParams defines parameters for GetSchedulesChannelId.
type GetSchedulesChannelIdParams struct {
	// StartAt 開始時刻
	StartAt StartAt `form:"startAt" json:"startAt"`

	// Days 取得日数
	Days Days `form:"days" json:"days"`

	// IsHalfWidth 半角文字で取得するか
	IsHalfWidth IsHalfWidth `form:"isHalfWidth" json:"isHalfWidth"`

	// NeedsRawExtended rawExtended が必要か
	NeedsRawExtended *NeedsRawExtended `form:"needsRawExtended,omitempty" json:"needsRawExtended,omitempty"`

	// IsFree 無料放送のみ取得するか (true: 無料放送, false: 有料放送, 無指定: 全て)
	IsFree *IsFreeProgram `form:"isFree,omitempty" json:"isFree,omitempty"`
}

// GetStreamsParams defines parameters for GetStreams.
type GetStreamsParams struct {
	// IsHalfWidth 半角文字で取得するか
	IsHalfWidth IsHalfWidth `form:"isHalfWidth" json:"isHalfWidth"`
}

// GetStreamsLiveChannelIdHlsParams defines parameters for GetStreamsLiveChannelIdHls.
type GetStreamsLiveChannelIdHlsParams struct {
	// Mode ストリーミング設定
	Mode StreamMode `form:"mode" json:"mode"`
}

// GetStreamsLiveChannelIdM2tsParams defines parameters for GetStreamsLiveChannelIdM2ts.
type GetStreamsLiveChannelIdM2tsParams struct {
	// Mode ストリーミング設定
	Mode StreamMode `form:"mode" json:"mode"`
}

// GetStreamsLiveChannelIdM2tsPlaylistParams defines parameters for GetStreamsLiveChannelIdM2tsPlaylist.
type GetStreamsLiveChannelIdM2tsPlaylistParams struct {
	// Mode ストリーミング設定
	Mode StreamMode `form:"mode" json:"mode"`
}

// GetStreamsLiveChannelIdM2tsllParams defines parameters for GetStreamsLiveChannelIdM2tsll.
type GetStreamsLiveChannelIdM2tsllParams struct {
	// Mode ストリーミング設定
	Mode StreamMode `form:"mode" json:"mode"`
}

// GetStreamsLiveChannelIdMp4Params defines parameters for GetStreamsLiveChannelIdMp4.
type GetStreamsLiveChannelIdMp4Params struct {
	// Mode ストリーミング設定
	Mode StreamMode `form:"mode" json:"mode"`
}

// GetStreamsLiveChannelIdWebmParams defines parameters for GetStreamsLiveChannelIdWebm.
type GetStreamsLiveChannelIdWebmParams struct {
	// Mode ストリーミング設定
	Mode StreamMode `form:"mode" json:"mode"`
}

// GetStreamsRecordedVideoFileIdHlsParams defines parameters for GetStreamsRecordedVideoFileIdHls.
type GetStreamsRecordedVideoFileIdHlsParams struct {
	// Ss 再生位置
	Ss StreamPlayPosition `form:"ss" json:"ss"`

	// Mode ストリーミング設定
	Mode StreamMode `form:"mode" json:"mode"`
}

// GetStreamsRecordedVideoFileIdMp4Params defines parameters for GetStreamsRecordedVideoFileIdMp4.
type GetStreamsRecordedVideoFileIdMp4Params struct {
	// Ss 再生位置
	Ss StreamPlayPosition `form:"ss" json:"ss"`

	// Mode ストリーミング設定
	Mode StreamMode `form:"mode" json:"mode"`
}

// GetStreamsRecordedVideoFileIdWebmParams defines parameters for GetStreamsRecordedVideoFileIdWebm.
type GetStreamsRecordedVideoFileIdWebmParams struct {
	// Ss 再生位置
	Ss StreamPlayPosition `form:"ss" json:"ss"`

	// Mode ストリーミング設定
	Mode StreamMode `form:"mode" json:"mode"`
}

// GetTagsParams defines parameters for GetTags.
type GetTagsParams struct {
	// Offset offset
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit limit
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Name name
	Name *QueryName `form:"name,omitempty" json:"name,omitempty"`

	// ExcludeTagId 除外する RecordedTagId
	ExcludeTagId *QueryExcludeRecordedTagId `form:"excludeTagId,omitempty" json:"excludeTagId,omitempty"`
}

// DeleteTagsTagIdRelateParams defines parameters for DeleteTagsTagIdRelate.
type DeleteTagsTagIdRelateParams struct {
	// RecordedId recorded id
	RecordedId *QueryRecordedId `form:"recordedId,omitempty" json:"recordedId,omitempty"`
}

// GetVideosVideoFileIdParams defines parameters for GetVideosVideoFileId.
type GetVideosVideoFileIdParams struct {
	// IsDownload ファイルをダウンロードするか
	IsDownload *IsDownload `form:"isDownload,omitempty" json:"isDownload,omitempty"`
}

// PostEncodeJSONRequestBody defines body for PostEncode for application/json ContentType.
type PostEncodeJSONRequestBody = AddManualEncodeProgramOption

// PostRecordedJSONRequestBody defines body for PostRecorded for application/json ContentType.
type PostRecordedJSONRequestBody = CreateNewRecordedOption

// PostReservesJSONRequestBody defines body for PostReserves for application/json ContentType.
type PostReservesJSONRequestBody = ManualReserveOption

// PutReservesReserveIdJSONRequestBody defines body for PutReservesReserveId for application/json ContentType.
type PutReservesReserveIdJSONRequestBody = EditManualReserveOption

// PostRulesJSONRequestBody defines body for PostRules for application/json ContentType.
type PostRulesJSONRequestBody = AddRuleOption

// PostRulesKeywordJSONRequestBody defines body for PostRulesKeyword for application/json ContentType.
type PostRulesKeywordJSONRequestBody = AddRuleOption

// PutRulesRuleIdJSONRequestBody defines body for PutRulesRuleId for application/json ContentType.
type PutRulesRuleIdJSONRequestBody = AddRuleOption

// PostSchedulesSearchJSONRequestBody defines body for PostSchedulesSearch for application/json ContentType.
type PostSchedulesSearchJSONRequestBody = ScheduleSearchOption

// PostTagsJSONRequestBody defines body for PostTags for application/json ContentType.
type PostTagsJSONRequestBody = AddRecordedTagOption

// PutTagsTagIdJSONRequestBody defines body for PutTagsTagId for application/json ContentType.
type PutTagsTagIdJSONRequestBody = AddRecordedTagOption

// PutTagsTagIdRelateJSONRequestBody defines body for PutTagsTagIdRelate for application/json ContentType.
type PutTagsTagIdRelateJSONRequestBody = RelateRecordedTagOption

// PostVideosUploadMultipartRequestBody defines body for PostVideosUpload for multipart/form-data ContentType.
type PostVideosUploadMultipartRequestBody = UploadVideoFileOption

// PostVideosVideoFileIdKodiJSONRequestBody defines body for PostVideosVideoFileIdKodi for application/json ContentType.
type PostVideosVideoFileIdKodiJSONRequestBody = SendVideoLinkToKodiOption

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetChannels request
	GetChannels(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetChannelsChannelIdLogo request
	GetChannelsChannelIdLogo(ctx context.Context, channelId PathChannelId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetConfig request
	GetConfig(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDropLogsDropLogFileId request
	GetDropLogsDropLogFileId(ctx context.Context, dropLogFileId PathDropLogFileId, params *GetDropLogsDropLogFileIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEncode request
	GetEncode(ctx context.Context, params *GetEncodeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostEncodeWithBody request with any body
	PostEncodeWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostEncode(ctx context.Context, body PostEncodeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteEncodeEncodeId request
	DeleteEncodeEncodeId(ctx context.Context, encodeId PathEncodeId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetIptvChannelM3u8 request
	GetIptvChannelM3u8(ctx context.Context, params *GetIptvChannelM3u8Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetIptvEpgXml request
	GetIptvEpgXml(ctx context.Context, params *GetIptvEpgXmlParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRecorded request
	GetRecorded(ctx context.Context, params *GetRecordedParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostRecordedWithBody request with any body
	PostRecordedWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostRecorded(ctx context.Context, body PostRecordedJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostRecordedCleanup request
	PostRecordedCleanup(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRecordedOptions request
	GetRecordedOptions(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteRecordedRecordedId request
	DeleteRecordedRecordedId(ctx context.Context, recordedId PathRecordedId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRecordedRecordedId request
	GetRecordedRecordedId(ctx context.Context, recordedId PathRecordedId, params *GetRecordedRecordedIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteRecordedRecordedIdEncode request
	DeleteRecordedRecordedIdEncode(ctx context.Context, recordedId PathRecordedId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutRecordedRecordedIdProtect request
	PutRecordedRecordedIdProtect(ctx context.Context, recordedId PathRecordedId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutRecordedRecordedIdUnprotect request
	PutRecordedRecordedIdUnprotect(ctx context.Context, recordedId PathRecordedId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRecording request
	GetRecording(ctx context.Context, params *GetRecordingParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostRecordingResettimer request
	PostRecordingResettimer(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetReserves request
	GetReserves(ctx context.Context, params *GetReservesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostReservesWithBody request with any body
	PostReservesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostReserves(ctx context.Context, body PostReservesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetReservesCnts request
	GetReservesCnts(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetReservesLists request
	GetReservesLists(ctx context.Context, params *GetReservesListsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostReservesUpdate request
	PostReservesUpdate(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteReservesReserveId request
	DeleteReservesReserveId(ctx context.Context, reserveId PathReserveId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetReservesReserveId request
	GetReservesReserveId(ctx context.Context, reserveId PathReserveId, params *GetReservesReserveIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutReservesReserveIdWithBody request with any body
	PutReservesReserveIdWithBody(ctx context.Context, reserveId PathReserveId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutReservesReserveId(ctx context.Context, reserveId PathReserveId, body PutReservesReserveIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteReservesReserveIdOverlap request
	DeleteReservesReserveIdOverlap(ctx context.Context, reserveId PathReserveId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteReservesReserveIdSkip request
	DeleteReservesReserveIdSkip(ctx context.Context, reserveId PathReserveId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRules request
	GetRules(ctx context.Context, params *GetRulesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostRulesWithBody request with any body
	PostRulesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostRules(ctx context.Context, body PostRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRulesKeyword request
	GetRulesKeyword(ctx context.Context, params *GetRulesKeywordParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostRulesKeywordWithBody request with any body
	PostRulesKeywordWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostRulesKeyword(ctx context.Context, body PostRulesKeywordJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteRulesRuleId request
	DeleteRulesRuleId(ctx context.Context, ruleId PathRuleId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRulesRuleId request
	GetRulesRuleId(ctx context.Context, ruleId PathRuleId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutRulesRuleIdWithBody request with any body
	PutRulesRuleIdWithBody(ctx context.Context, ruleId PathRuleId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutRulesRuleId(ctx context.Context, ruleId PathRuleId, body PutRulesRuleIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutRulesRuleIdDisable request
	PutRulesRuleIdDisable(ctx context.Context, ruleId PathRuleId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutRulesRuleIdEnable request
	PutRulesRuleIdEnable(ctx context.Context, ruleId PathRuleId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSchedules request
	GetSchedules(ctx context.Context, params *GetSchedulesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSchedulesBroadcasting request
	GetSchedulesBroadcasting(ctx context.Context, params *GetSchedulesBroadcastingParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSchedulesDetailProgramId request
	GetSchedulesDetailProgramId(ctx context.Context, programId PathProgramId, params *GetSchedulesDetailProgramIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostSchedulesSearchWithBody request with any body
	PostSchedulesSearchWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostSchedulesSearch(ctx context.Context, body PostSchedulesSearchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSchedulesChannelId request
	GetSchedulesChannelId(ctx context.Context, channelId PathChannelId, params *GetSchedulesChannelIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStorages request
	GetStorages(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteStreams request
	DeleteStreams(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStreams request
	GetStreams(ctx context.Context, params *GetStreamsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStreamsLiveChannelIdHls request
	GetStreamsLiveChannelIdHls(ctx context.Context, channelId PathChannelId, params *GetStreamsLiveChannelIdHlsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStreamsLiveChannelIdM2ts request
	GetStreamsLiveChannelIdM2ts(ctx context.Context, channelId PathChannelId, params *GetStreamsLiveChannelIdM2tsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStreamsLiveChannelIdM2tsPlaylist request
	GetStreamsLiveChannelIdM2tsPlaylist(ctx context.Context, channelId PathChannelId, params *GetStreamsLiveChannelIdM2tsPlaylistParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStreamsLiveChannelIdM2tsll request
	GetStreamsLiveChannelIdM2tsll(ctx context.Context, channelId PathChannelId, params *GetStreamsLiveChannelIdM2tsllParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStreamsLiveChannelIdMp4 request
	GetStreamsLiveChannelIdMp4(ctx context.Context, channelId PathChannelId, params *GetStreamsLiveChannelIdMp4Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStreamsLiveChannelIdWebm request
	GetStreamsLiveChannelIdWebm(ctx context.Context, channelId PathChannelId, params *GetStreamsLiveChannelIdWebmParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStreamsRecordedVideoFileIdHls request
	GetStreamsRecordedVideoFileIdHls(ctx context.Context, videoFileId PathVideoFileId, params *GetStreamsRecordedVideoFileIdHlsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStreamsRecordedVideoFileIdMp4 request
	GetStreamsRecordedVideoFileIdMp4(ctx context.Context, videoFileId PathVideoFileId, params *GetStreamsRecordedVideoFileIdMp4Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStreamsRecordedVideoFileIdWebm request
	GetStreamsRecordedVideoFileIdWebm(ctx context.Context, videoFileId PathVideoFileId, params *GetStreamsRecordedVideoFileIdWebmParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteStreamsStreamId request
	DeleteStreamsStreamId(ctx context.Context, streamId PathStreamId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutStreamsStreamIdKeep request
	PutStreamsStreamIdKeep(ctx context.Context, streamId PathStreamId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTags request
	GetTags(ctx context.Context, params *GetTagsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostTagsWithBody request with any body
	PostTagsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostTags(ctx context.Context, body PostTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteTagsTagId request
	DeleteTagsTagId(ctx context.Context, tagId PathRecordedTagId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutTagsTagIdWithBody request with any body
	PutTagsTagIdWithBody(ctx context.Context, tagId PathRecordedTagId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutTagsTagId(ctx context.Context, tagId PathRecordedTagId, body PutTagsTagIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteTagsTagIdRelate request
	DeleteTagsTagIdRelate(ctx context.Context, tagId PathRecordedTagId, params *DeleteTagsTagIdRelateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutTagsTagIdRelateWithBody request with any body
	PutTagsTagIdRelateWithBody(ctx context.Context, tagId PathRecordedTagId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutTagsTagIdRelate(ctx context.Context, tagId PathRecordedTagId, body PutTagsTagIdRelateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostThumbnails request
	PostThumbnails(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostThumbnailsCleanup request
	PostThumbnailsCleanup(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetThumbnailsThumbnailId request
	GetThumbnailsThumbnailId(ctx context.Context, thumbnailId PathThumbnailId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVersion request
	GetVersion(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostVideosUploadWithBody request with any body
	PostVideosUploadWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteVideosVideoFileId request
	DeleteVideosVideoFileId(ctx context.Context, videoFileId PathVideoFileId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVideosVideoFileId request
	GetVideosVideoFileId(ctx context.Context, videoFileId PathVideoFileId, params *GetVideosVideoFileIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVideosVideoFileIdDuration request
	GetVideosVideoFileIdDuration(ctx context.Context, videoFileId PathVideoFileId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostVideosVideoFileIdKodiWithBody request with any body
	PostVideosVideoFileIdKodiWithBody(ctx context.Context, videoFileId PathVideoFileId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostVideosVideoFileIdKodi(ctx context.Context, videoFileId PathVideoFileId, body PostVideosVideoFileIdKodiJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVideosVideoFileIdPlaylist request
	GetVideosVideoFileIdPlaylist(ctx context.Context, videoFileId PathVideoFileId, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetChannels(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetChannelsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetChannelsChannelIdLogo(ctx context.Context, channelId PathChannelId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetChannelsChannelIdLogoRequest(c.Server, channelId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetConfig(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetConfigRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDropLogsDropLogFileId(ctx context.Context, dropLogFileId PathDropLogFileId, params *GetDropLogsDropLogFileIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDropLogsDropLogFileIdRequest(c.Server, dropLogFileId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEncode(ctx context.Context, params *GetEncodeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEncodeRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostEncodeWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostEncodeRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostEncode(ctx context.Context, body PostEncodeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostEncodeRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteEncodeEncodeId(ctx context.Context, encodeId PathEncodeId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteEncodeEncodeIdRequest(c.Server, encodeId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetIptvChannelM3u8(ctx context.Context, params *GetIptvChannelM3u8Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetIptvChannelM3u8Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetIptvEpgXml(ctx context.Context, params *GetIptvEpgXmlParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetIptvEpgXmlRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRecorded(ctx context.Context, params *GetRecordedParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRecordedRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostRecordedWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostRecordedRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostRecorded(ctx context.Context, body PostRecordedJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostRecordedRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostRecordedCleanup(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostRecordedCleanupRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRecordedOptions(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRecordedOptionsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteRecordedRecordedId(ctx context.Context, recordedId PathRecordedId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteRecordedRecordedIdRequest(c.Server, recordedId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRecordedRecordedId(ctx context.Context, recordedId PathRecordedId, params *GetRecordedRecordedIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRecordedRecordedIdRequest(c.Server, recordedId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteRecordedRecordedIdEncode(ctx context.Context, recordedId PathRecordedId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteRecordedRecordedIdEncodeRequest(c.Server, recordedId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutRecordedRecordedIdProtect(ctx context.Context, recordedId PathRecordedId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutRecordedRecordedIdProtectRequest(c.Server, recordedId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutRecordedRecordedIdUnprotect(ctx context.Context, recordedId PathRecordedId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutRecordedRecordedIdUnprotectRequest(c.Server, recordedId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRecording(ctx context.Context, params *GetRecordingParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRecordingRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostRecordingResettimer(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostRecordingResettimerRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetReserves(ctx context.Context, params *GetReservesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetReservesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostReservesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostReservesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostReserves(ctx context.Context, body PostReservesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostReservesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetReservesCnts(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetReservesCntsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetReservesLists(ctx context.Context, params *GetReservesListsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetReservesListsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostReservesUpdate(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostReservesUpdateRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteReservesReserveId(ctx context.Context, reserveId PathReserveId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteReservesReserveIdRequest(c.Server, reserveId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetReservesReserveId(ctx context.Context, reserveId PathReserveId, params *GetReservesReserveIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetReservesReserveIdRequest(c.Server, reserveId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutReservesReserveIdWithBody(ctx context.Context, reserveId PathReserveId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutReservesReserveIdRequestWithBody(c.Server, reserveId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutReservesReserveId(ctx context.Context, reserveId PathReserveId, body PutReservesReserveIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutReservesReserveIdRequest(c.Server, reserveId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteReservesReserveIdOverlap(ctx context.Context, reserveId PathReserveId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteReservesReserveIdOverlapRequest(c.Server, reserveId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteReservesReserveIdSkip(ctx context.Context, reserveId PathReserveId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteReservesReserveIdSkipRequest(c.Server, reserveId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRules(ctx context.Context, params *GetRulesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRulesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostRulesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostRulesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostRules(ctx context.Context, body PostRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostRulesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRulesKeyword(ctx context.Context, params *GetRulesKeywordParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRulesKeywordRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostRulesKeywordWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostRulesKeywordRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostRulesKeyword(ctx context.Context, body PostRulesKeywordJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostRulesKeywordRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteRulesRuleId(ctx context.Context, ruleId PathRuleId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteRulesRuleIdRequest(c.Server, ruleId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRulesRuleId(ctx context.Context, ruleId PathRuleId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRulesRuleIdRequest(c.Server, ruleId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutRulesRuleIdWithBody(ctx context.Context, ruleId PathRuleId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutRulesRuleIdRequestWithBody(c.Server, ruleId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutRulesRuleId(ctx context.Context, ruleId PathRuleId, body PutRulesRuleIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutRulesRuleIdRequest(c.Server, ruleId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutRulesRuleIdDisable(ctx context.Context, ruleId PathRuleId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutRulesRuleIdDisableRequest(c.Server, ruleId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutRulesRuleIdEnable(ctx context.Context, ruleId PathRuleId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutRulesRuleIdEnableRequest(c.Server, ruleId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSchedules(ctx context.Context, params *GetSchedulesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSchedulesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSchedulesBroadcasting(ctx context.Context, params *GetSchedulesBroadcastingParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSchedulesBroadcastingRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSchedulesDetailProgramId(ctx context.Context, programId PathProgramId, params *GetSchedulesDetailProgramIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSchedulesDetailProgramIdRequest(c.Server, programId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSchedulesSearchWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSchedulesSearchRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSchedulesSearch(ctx context.Context, body PostSchedulesSearchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSchedulesSearchRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSchedulesChannelId(ctx context.Context, channelId PathChannelId, params *GetSchedulesChannelIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSchedulesChannelIdRequest(c.Server, channelId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStorages(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStoragesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteStreams(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteStreamsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStreams(ctx context.Context, params *GetStreamsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStreamsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStreamsLiveChannelIdHls(ctx context.Context, channelId PathChannelId, params *GetStreamsLiveChannelIdHlsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStreamsLiveChannelIdHlsRequest(c.Server, channelId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStreamsLiveChannelIdM2ts(ctx context.Context, channelId PathChannelId, params *GetStreamsLiveChannelIdM2tsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStreamsLiveChannelIdM2tsRequest(c.Server, channelId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStreamsLiveChannelIdM2tsPlaylist(ctx context.Context, channelId PathChannelId, params *GetStreamsLiveChannelIdM2tsPlaylistParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStreamsLiveChannelIdM2tsPlaylistRequest(c.Server, channelId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStreamsLiveChannelIdM2tsll(ctx context.Context, channelId PathChannelId, params *GetStreamsLiveChannelIdM2tsllParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStreamsLiveChannelIdM2tsllRequest(c.Server, channelId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStreamsLiveChannelIdMp4(ctx context.Context, channelId PathChannelId, params *GetStreamsLiveChannelIdMp4Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStreamsLiveChannelIdMp4Request(c.Server, channelId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStreamsLiveChannelIdWebm(ctx context.Context, channelId PathChannelId, params *GetStreamsLiveChannelIdWebmParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStreamsLiveChannelIdWebmRequest(c.Server, channelId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStreamsRecordedVideoFileIdHls(ctx context.Context, videoFileId PathVideoFileId, params *GetStreamsRecordedVideoFileIdHlsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStreamsRecordedVideoFileIdHlsRequest(c.Server, videoFileId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStreamsRecordedVideoFileIdMp4(ctx context.Context, videoFileId PathVideoFileId, params *GetStreamsRecordedVideoFileIdMp4Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStreamsRecordedVideoFileIdMp4Request(c.Server, videoFileId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStreamsRecordedVideoFileIdWebm(ctx context.Context, videoFileId PathVideoFileId, params *GetStreamsRecordedVideoFileIdWebmParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStreamsRecordedVideoFileIdWebmRequest(c.Server, videoFileId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteStreamsStreamId(ctx context.Context, streamId PathStreamId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteStreamsStreamIdRequest(c.Server, streamId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutStreamsStreamIdKeep(ctx context.Context, streamId PathStreamId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutStreamsStreamIdKeepRequest(c.Server, streamId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTags(ctx context.Context, params *GetTagsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTagsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostTagsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostTagsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostTags(ctx context.Context, body PostTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostTagsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteTagsTagId(ctx context.Context, tagId PathRecordedTagId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTagsTagIdRequest(c.Server, tagId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutTagsTagIdWithBody(ctx context.Context, tagId PathRecordedTagId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutTagsTagIdRequestWithBody(c.Server, tagId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutTagsTagId(ctx context.Context, tagId PathRecordedTagId, body PutTagsTagIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutTagsTagIdRequest(c.Server, tagId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteTagsTagIdRelate(ctx context.Context, tagId PathRecordedTagId, params *DeleteTagsTagIdRelateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTagsTagIdRelateRequest(c.Server, tagId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutTagsTagIdRelateWithBody(ctx context.Context, tagId PathRecordedTagId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutTagsTagIdRelateRequestWithBody(c.Server, tagId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutTagsTagIdRelate(ctx context.Context, tagId PathRecordedTagId, body PutTagsTagIdRelateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutTagsTagIdRelateRequest(c.Server, tagId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostThumbnails(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostThumbnailsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostThumbnailsCleanup(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostThumbnailsCleanupRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetThumbnailsThumbnailId(ctx context.Context, thumbnailId PathThumbnailId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetThumbnailsThumbnailIdRequest(c.Server, thumbnailId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVersion(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVersionRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostVideosUploadWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostVideosUploadRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteVideosVideoFileId(ctx context.Context, videoFileId PathVideoFileId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteVideosVideoFileIdRequest(c.Server, videoFileId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVideosVideoFileId(ctx context.Context, videoFileId PathVideoFileId, params *GetVideosVideoFileIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVideosVideoFileIdRequest(c.Server, videoFileId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVideosVideoFileIdDuration(ctx context.Context, videoFileId PathVideoFileId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVideosVideoFileIdDurationRequest(c.Server, videoFileId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostVideosVideoFileIdKodiWithBody(ctx context.Context, videoFileId PathVideoFileId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostVideosVideoFileIdKodiRequestWithBody(c.Server, videoFileId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostVideosVideoFileIdKodi(ctx context.Context, videoFileId PathVideoFileId, body PostVideosVideoFileIdKodiJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostVideosVideoFileIdKodiRequest(c.Server, videoFileId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVideosVideoFileIdPlaylist(ctx context.Context, videoFileId PathVideoFileId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVideosVideoFileIdPlaylistRequest(c.Server, videoFileId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetChannelsRequest generates requests for GetChannels
func NewGetChannelsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/channels")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetChannelsChannelIdLogoRequest generates requests for GetChannelsChannelIdLogo
func NewGetChannelsChannelIdLogoRequest(server string, channelId PathChannelId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "channelId", runtime.ParamLocationPath, channelId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/channels/%s/logo", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetConfigRequest generates requests for GetConfig
func NewGetConfigRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/config")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDropLogsDropLogFileIdRequest generates requests for GetDropLogsDropLogFileId
func NewGetDropLogsDropLogFileIdRequest(server string, dropLogFileId PathDropLogFileId, params *GetDropLogsDropLogFileIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "dropLogFileId", runtime.ParamLocationPath, dropLogFileId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dropLogs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Maxsize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxsize", runtime.ParamLocationQuery, *params.Maxsize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetEncodeRequest generates requests for GetEncode
func NewGetEncodeRequest(server string, params *GetEncodeParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/encode")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isHalfWidth", runtime.ParamLocationQuery, params.IsHalfWidth); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostEncodeRequest calls the generic PostEncode builder with application/json body
func NewPostEncodeRequest(server string, body PostEncodeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostEncodeRequestWithBody(server, "application/json", bodyReader)
}

// NewPostEncodeRequestWithBody generates requests for PostEncode with any type of body
func NewPostEncodeRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/encode")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteEncodeEncodeIdRequest generates requests for DeleteEncodeEncodeId
func NewDeleteEncodeEncodeIdRequest(server string, encodeId PathEncodeId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "encodeId", runtime.ParamLocationPath, encodeId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/encode/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetIptvChannelM3u8Request generates requests for GetIptvChannelM3u8
func NewGetIptvChannelM3u8Request(server string, params *GetIptvChannelM3u8Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iptv/channel.m3u8")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IsHalfWidth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isHalfWidth", runtime.ParamLocationQuery, *params.IsHalfWidth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mode", runtime.ParamLocationQuery, params.Mode); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetIptvEpgXmlRequest generates requests for GetIptvEpgXml
func NewGetIptvEpgXmlRequest(server string, params *GetIptvEpgXmlParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iptv/epg.xml")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IsHalfWidth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isHalfWidth", runtime.ParamLocationQuery, *params.IsHalfWidth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Days != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "days", runtime.ParamLocationQuery, *params.Days); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRecordedRequest generates requests for GetRecorded
func NewGetRecordedRequest(server string, params *GetRecordedParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/recorded")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isHalfWidth", runtime.ParamLocationQuery, params.IsHalfWidth); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsReverse != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isReverse", runtime.ParamLocationQuery, *params.IsReverse); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RuleId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ruleId", runtime.ParamLocationQuery, *params.RuleId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ChannelId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "channelId", runtime.ParamLocationQuery, *params.ChannelId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Genre != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "genre", runtime.ParamLocationQuery, *params.Genre); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Keyword != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "keyword", runtime.ParamLocationQuery, *params.Keyword); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HasOriginalFile != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hasOriginalFile", runtime.ParamLocationQuery, *params.HasOriginalFile); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostRecordedRequest calls the generic PostRecorded builder with application/json body
func NewPostRecordedRequest(server string, body PostRecordedJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostRecordedRequestWithBody(server, "application/json", bodyReader)
}

// NewPostRecordedRequestWithBody generates requests for PostRecorded with any type of body
func NewPostRecordedRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/recorded")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostRecordedCleanupRequest generates requests for PostRecordedCleanup
func NewPostRecordedCleanupRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/recorded/cleanup")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRecordedOptionsRequest generates requests for GetRecordedOptions
func NewGetRecordedOptionsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/recorded/options")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteRecordedRecordedIdRequest generates requests for DeleteRecordedRecordedId
func NewDeleteRecordedRecordedIdRequest(server string, recordedId PathRecordedId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "recordedId", runtime.ParamLocationPath, recordedId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/recorded/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRecordedRecordedIdRequest generates requests for GetRecordedRecordedId
func NewGetRecordedRecordedIdRequest(server string, recordedId PathRecordedId, params *GetRecordedRecordedIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "recordedId", runtime.ParamLocationPath, recordedId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/recorded/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isHalfWidth", runtime.ParamLocationQuery, params.IsHalfWidth); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteRecordedRecordedIdEncodeRequest generates requests for DeleteRecordedRecordedIdEncode
func NewDeleteRecordedRecordedIdEncodeRequest(server string, recordedId PathRecordedId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "recordedId", runtime.ParamLocationPath, recordedId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/recorded/%s/encode", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPutRecordedRecordedIdProtectRequest generates requests for PutRecordedRecordedIdProtect
func NewPutRecordedRecordedIdProtectRequest(server string, recordedId PathRecordedId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "recordedId", runtime.ParamLocationPath, recordedId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/recorded/%s/protect", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPutRecordedRecordedIdUnprotectRequest generates requests for PutRecordedRecordedIdUnprotect
func NewPutRecordedRecordedIdUnprotectRequest(server string, recordedId PathRecordedId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "recordedId", runtime.ParamLocationPath, recordedId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/recorded/%s/unprotect", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRecordingRequest generates requests for GetRecording
func NewGetRecordingRequest(server string, params *GetRecordingParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/recording")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isHalfWidth", runtime.ParamLocationQuery, params.IsHalfWidth); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostRecordingResettimerRequest generates requests for PostRecordingResettimer
func NewPostRecordingResettimerRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/recording/resettimer")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetReservesRequest generates requests for GetReserves
func NewGetReservesRequest(server string, params *GetReservesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/reserves")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isHalfWidth", runtime.ParamLocationQuery, params.IsHalfWidth); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.RuleId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ruleId", runtime.ParamLocationQuery, *params.RuleId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostReservesRequest calls the generic PostReserves builder with application/json body
func NewPostReservesRequest(server string, body PostReservesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostReservesRequestWithBody(server, "application/json", bodyReader)
}

// NewPostReservesRequestWithBody generates requests for PostReserves with any type of body
func NewPostReservesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/reserves")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetReservesCntsRequest generates requests for GetReservesCnts
func NewGetReservesCntsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/reserves/cnts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetReservesListsRequest generates requests for GetReservesLists
func NewGetReservesListsRequest(server string, params *GetReservesListsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/reserves/lists")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startAt", runtime.ParamLocationQuery, params.StartAt); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "endAt", runtime.ParamLocationQuery, params.EndAt); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostReservesUpdateRequest generates requests for PostReservesUpdate
func NewPostReservesUpdateRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/reserves/update")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteReservesReserveIdRequest generates requests for DeleteReservesReserveId
func NewDeleteReservesReserveIdRequest(server string, reserveId PathReserveId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "reserveId", runtime.ParamLocationPath, reserveId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/reserves/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetReservesReserveIdRequest generates requests for GetReservesReserveId
func NewGetReservesReserveIdRequest(server string, reserveId PathReserveId, params *GetReservesReserveIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "reserveId", runtime.ParamLocationPath, reserveId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/reserves/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isHalfWidth", runtime.ParamLocationQuery, params.IsHalfWidth); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPutReservesReserveIdRequest calls the generic PutReservesReserveId builder with application/json body
func NewPutReservesReserveIdRequest(server string, reserveId PathReserveId, body PutReservesReserveIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutReservesReserveIdRequestWithBody(server, reserveId, "application/json", bodyReader)
}

// NewPutReservesReserveIdRequestWithBody generates requests for PutReservesReserveId with any type of body
func NewPutReservesReserveIdRequestWithBody(server string, reserveId PathReserveId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "reserveId", runtime.ParamLocationPath, reserveId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/reserves/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteReservesReserveIdOverlapRequest generates requests for DeleteReservesReserveIdOverlap
func NewDeleteReservesReserveIdOverlapRequest(server string, reserveId PathReserveId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "reserveId", runtime.ParamLocationPath, reserveId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/reserves/%s/overlap", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteReservesReserveIdSkipRequest generates requests for DeleteReservesReserveIdSkip
func NewDeleteReservesReserveIdSkipRequest(server string, reserveId PathReserveId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "reserveId", runtime.ParamLocationPath, reserveId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/reserves/%s/skip", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRulesRequest generates requests for GetRules
func NewGetRulesRequest(server string, params *GetRulesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rules")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Keyword != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "keyword", runtime.ParamLocationQuery, *params.Keyword); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostRulesRequest calls the generic PostRules builder with application/json body
func NewPostRulesRequest(server string, body PostRulesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostRulesRequestWithBody(server, "application/json", bodyReader)
}

// NewPostRulesRequestWithBody generates requests for PostRules with any type of body
func NewPostRulesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rules")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetRulesKeywordRequest generates requests for GetRulesKeyword
func NewGetRulesKeywordRequest(server string, params *GetRulesKeywordParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rules/keyword")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Keyword != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "keyword", runtime.ParamLocationQuery, *params.Keyword); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostRulesKeywordRequest calls the generic PostRulesKeyword builder with application/json body
func NewPostRulesKeywordRequest(server string, body PostRulesKeywordJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostRulesKeywordRequestWithBody(server, "application/json", bodyReader)
}

// NewPostRulesKeywordRequestWithBody generates requests for PostRulesKeyword with any type of body
func NewPostRulesKeywordRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rules/keyword")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteRulesRuleIdRequest generates requests for DeleteRulesRuleId
func NewDeleteRulesRuleIdRequest(server string, ruleId PathRuleId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ruleId", runtime.ParamLocationPath, ruleId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rules/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRulesRuleIdRequest generates requests for GetRulesRuleId
func NewGetRulesRuleIdRequest(server string, ruleId PathRuleId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ruleId", runtime.ParamLocationPath, ruleId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rules/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPutRulesRuleIdRequest calls the generic PutRulesRuleId builder with application/json body
func NewPutRulesRuleIdRequest(server string, ruleId PathRuleId, body PutRulesRuleIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutRulesRuleIdRequestWithBody(server, ruleId, "application/json", bodyReader)
}

// NewPutRulesRuleIdRequestWithBody generates requests for PutRulesRuleId with any type of body
func NewPutRulesRuleIdRequestWithBody(server string, ruleId PathRuleId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ruleId", runtime.ParamLocationPath, ruleId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rules/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPutRulesRuleIdDisableRequest generates requests for PutRulesRuleIdDisable
func NewPutRulesRuleIdDisableRequest(server string, ruleId PathRuleId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ruleId", runtime.ParamLocationPath, ruleId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rules/%s/disable", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPutRulesRuleIdEnableRequest generates requests for PutRulesRuleIdEnable
func NewPutRulesRuleIdEnableRequest(server string, ruleId PathRuleId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ruleId", runtime.ParamLocationPath, ruleId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rules/%s/enable", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSchedulesRequest generates requests for GetSchedules
func NewGetSchedulesRequest(server string, params *GetSchedulesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/schedules")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startAt", runtime.ParamLocationQuery, params.StartAt); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "endAt", runtime.ParamLocationQuery, params.EndAt); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isHalfWidth", runtime.ParamLocationQuery, params.IsHalfWidth); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.NeedsRawExtended != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "needsRawExtended", runtime.ParamLocationQuery, *params.NeedsRawExtended); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsFree != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isFree", runtime.ParamLocationQuery, *params.IsFree); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "GR", runtime.ParamLocationQuery, params.GR); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "BS", runtime.ParamLocationQuery, params.BS); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "CS", runtime.ParamLocationQuery, params.CS); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "SKY", runtime.ParamLocationQuery, params.SKY); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSchedulesBroadcastingRequest generates requests for GetSchedulesBroadcasting
func NewGetSchedulesBroadcastingRequest(server string, params *GetSchedulesBroadcastingParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/schedules/broadcasting")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Time != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "time", runtime.ParamLocationQuery, *params.Time); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isHalfWidth", runtime.ParamLocationQuery, params.IsHalfWidth); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSchedulesDetailProgramIdRequest generates requests for GetSchedulesDetailProgramId
func NewGetSchedulesDetailProgramIdRequest(server string, programId PathProgramId, params *GetSchedulesDetailProgramIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "programId", runtime.ParamLocationPath, programId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/schedules/detail/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isHalfWidth", runtime.ParamLocationQuery, params.IsHalfWidth); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostSchedulesSearchRequest calls the generic PostSchedulesSearch builder with application/json body
func NewPostSchedulesSearchRequest(server string, body PostSchedulesSearchJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostSchedulesSearchRequestWithBody(server, "application/json", bodyReader)
}

// NewPostSchedulesSearchRequestWithBody generates requests for PostSchedulesSearch with any type of body
func NewPostSchedulesSearchRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/schedules/search")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSchedulesChannelIdRequest generates requests for GetSchedulesChannelId
func NewGetSchedulesChannelIdRequest(server string, channelId PathChannelId, params *GetSchedulesChannelIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "channelId", runtime.ParamLocationPath, channelId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/schedules/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startAt", runtime.ParamLocationQuery, params.StartAt); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "days", runtime.ParamLocationQuery, params.Days); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isHalfWidth", runtime.ParamLocationQuery, params.IsHalfWidth); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.NeedsRawExtended != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "needsRawExtended", runtime.ParamLocationQuery, *params.NeedsRawExtended); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsFree != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isFree", runtime.ParamLocationQuery, *params.IsFree); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStoragesRequest generates requests for GetStorages
func NewGetStoragesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/storages")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteStreamsRequest generates requests for DeleteStreams
func NewDeleteStreamsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/streams")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStreamsRequest generates requests for GetStreams
func NewGetStreamsRequest(server string, params *GetStreamsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/streams")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isHalfWidth", runtime.ParamLocationQuery, params.IsHalfWidth); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStreamsLiveChannelIdHlsRequest generates requests for GetStreamsLiveChannelIdHls
func NewGetStreamsLiveChannelIdHlsRequest(server string, channelId PathChannelId, params *GetStreamsLiveChannelIdHlsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "channelId", runtime.ParamLocationPath, channelId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/streams/live/%s/hls", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mode", runtime.ParamLocationQuery, params.Mode); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStreamsLiveChannelIdM2tsRequest generates requests for GetStreamsLiveChannelIdM2ts
func NewGetStreamsLiveChannelIdM2tsRequest(server string, channelId PathChannelId, params *GetStreamsLiveChannelIdM2tsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "channelId", runtime.ParamLocationPath, channelId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/streams/live/%s/m2ts", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mode", runtime.ParamLocationQuery, params.Mode); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStreamsLiveChannelIdM2tsPlaylistRequest generates requests for GetStreamsLiveChannelIdM2tsPlaylist
func NewGetStreamsLiveChannelIdM2tsPlaylistRequest(server string, channelId PathChannelId, params *GetStreamsLiveChannelIdM2tsPlaylistParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "channelId", runtime.ParamLocationPath, channelId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/streams/live/%s/m2ts/playlist", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mode", runtime.ParamLocationQuery, params.Mode); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStreamsLiveChannelIdM2tsllRequest generates requests for GetStreamsLiveChannelIdM2tsll
func NewGetStreamsLiveChannelIdM2tsllRequest(server string, channelId PathChannelId, params *GetStreamsLiveChannelIdM2tsllParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "channelId", runtime.ParamLocationPath, channelId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/streams/live/%s/m2tsll", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mode", runtime.ParamLocationQuery, params.Mode); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStreamsLiveChannelIdMp4Request generates requests for GetStreamsLiveChannelIdMp4
func NewGetStreamsLiveChannelIdMp4Request(server string, channelId PathChannelId, params *GetStreamsLiveChannelIdMp4Params) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "channelId", runtime.ParamLocationPath, channelId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/streams/live/%s/mp4", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mode", runtime.ParamLocationQuery, params.Mode); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStreamsLiveChannelIdWebmRequest generates requests for GetStreamsLiveChannelIdWebm
func NewGetStreamsLiveChannelIdWebmRequest(server string, channelId PathChannelId, params *GetStreamsLiveChannelIdWebmParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "channelId", runtime.ParamLocationPath, channelId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/streams/live/%s/webm", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mode", runtime.ParamLocationQuery, params.Mode); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStreamsRecordedVideoFileIdHlsRequest generates requests for GetStreamsRecordedVideoFileIdHls
func NewGetStreamsRecordedVideoFileIdHlsRequest(server string, videoFileId PathVideoFileId, params *GetStreamsRecordedVideoFileIdHlsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "videoFileId", runtime.ParamLocationPath, videoFileId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/streams/recorded/%s/hls", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ss", runtime.ParamLocationQuery, params.Ss); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mode", runtime.ParamLocationQuery, params.Mode); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStreamsRecordedVideoFileIdMp4Request generates requests for GetStreamsRecordedVideoFileIdMp4
func NewGetStreamsRecordedVideoFileIdMp4Request(server string, videoFileId PathVideoFileId, params *GetStreamsRecordedVideoFileIdMp4Params) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "videoFileId", runtime.ParamLocationPath, videoFileId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/streams/recorded/%s/mp4", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ss", runtime.ParamLocationQuery, params.Ss); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mode", runtime.ParamLocationQuery, params.Mode); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStreamsRecordedVideoFileIdWebmRequest generates requests for GetStreamsRecordedVideoFileIdWebm
func NewGetStreamsRecordedVideoFileIdWebmRequest(server string, videoFileId PathVideoFileId, params *GetStreamsRecordedVideoFileIdWebmParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "videoFileId", runtime.ParamLocationPath, videoFileId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/streams/recorded/%s/webm", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ss", runtime.ParamLocationQuery, params.Ss); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mode", runtime.ParamLocationQuery, params.Mode); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteStreamsStreamIdRequest generates requests for DeleteStreamsStreamId
func NewDeleteStreamsStreamIdRequest(server string, streamId PathStreamId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "streamId", runtime.ParamLocationPath, streamId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/streams/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPutStreamsStreamIdKeepRequest generates requests for PutStreamsStreamIdKeep
func NewPutStreamsStreamIdKeepRequest(server string, streamId PathStreamId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "streamId", runtime.ParamLocationPath, streamId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/streams/%s/keep", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTagsRequest generates requests for GetTags
func NewGetTagsRequest(server string, params *GetTagsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tags")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExcludeTagId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "excludeTagId", runtime.ParamLocationQuery, *params.ExcludeTagId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostTagsRequest calls the generic PostTags builder with application/json body
func NewPostTagsRequest(server string, body PostTagsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostTagsRequestWithBody(server, "application/json", bodyReader)
}

// NewPostTagsRequestWithBody generates requests for PostTags with any type of body
func NewPostTagsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tags")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteTagsTagIdRequest generates requests for DeleteTagsTagId
func NewDeleteTagsTagIdRequest(server string, tagId PathRecordedTagId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tagId", runtime.ParamLocationPath, tagId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tags/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPutTagsTagIdRequest calls the generic PutTagsTagId builder with application/json body
func NewPutTagsTagIdRequest(server string, tagId PathRecordedTagId, body PutTagsTagIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutTagsTagIdRequestWithBody(server, tagId, "application/json", bodyReader)
}

// NewPutTagsTagIdRequestWithBody generates requests for PutTagsTagId with any type of body
func NewPutTagsTagIdRequestWithBody(server string, tagId PathRecordedTagId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tagId", runtime.ParamLocationPath, tagId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tags/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteTagsTagIdRelateRequest generates requests for DeleteTagsTagIdRelate
func NewDeleteTagsTagIdRelateRequest(server string, tagId PathRecordedTagId, params *DeleteTagsTagIdRelateParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tagId", runtime.ParamLocationPath, tagId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tags/%s/relate", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.RecordedId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "recordedId", runtime.ParamLocationQuery, *params.RecordedId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPutTagsTagIdRelateRequest calls the generic PutTagsTagIdRelate builder with application/json body
func NewPutTagsTagIdRelateRequest(server string, tagId PathRecordedTagId, body PutTagsTagIdRelateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutTagsTagIdRelateRequestWithBody(server, tagId, "application/json", bodyReader)
}

// NewPutTagsTagIdRelateRequestWithBody generates requests for PutTagsTagIdRelate with any type of body
func NewPutTagsTagIdRelateRequestWithBody(server string, tagId PathRecordedTagId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tagId", runtime.ParamLocationPath, tagId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tags/%s/relate", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostThumbnailsRequest generates requests for PostThumbnails
func NewPostThumbnailsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/thumbnails")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostThumbnailsCleanupRequest generates requests for PostThumbnailsCleanup
func NewPostThumbnailsCleanupRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/thumbnails/cleanup")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetThumbnailsThumbnailIdRequest generates requests for GetThumbnailsThumbnailId
func NewGetThumbnailsThumbnailIdRequest(server string, thumbnailId PathThumbnailId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "thumbnailId", runtime.ParamLocationPath, thumbnailId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/thumbnails/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetVersionRequest generates requests for GetVersion
func NewGetVersionRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/version")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostVideosUploadRequestWithBody generates requests for PostVideosUpload with any type of body
func NewPostVideosUploadRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/videos/upload")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteVideosVideoFileIdRequest generates requests for DeleteVideosVideoFileId
func NewDeleteVideosVideoFileIdRequest(server string, videoFileId PathVideoFileId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "videoFileId", runtime.ParamLocationPath, videoFileId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/videos/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetVideosVideoFileIdRequest generates requests for GetVideosVideoFileId
func NewGetVideosVideoFileIdRequest(server string, videoFileId PathVideoFileId, params *GetVideosVideoFileIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "videoFileId", runtime.ParamLocationPath, videoFileId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/videos/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IsDownload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isDownload", runtime.ParamLocationQuery, *params.IsDownload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetVideosVideoFileIdDurationRequest generates requests for GetVideosVideoFileIdDuration
func NewGetVideosVideoFileIdDurationRequest(server string, videoFileId PathVideoFileId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "videoFileId", runtime.ParamLocationPath, videoFileId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/videos/%s/duration", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostVideosVideoFileIdKodiRequest calls the generic PostVideosVideoFileIdKodi builder with application/json body
func NewPostVideosVideoFileIdKodiRequest(server string, videoFileId PathVideoFileId, body PostVideosVideoFileIdKodiJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostVideosVideoFileIdKodiRequestWithBody(server, videoFileId, "application/json", bodyReader)
}

// NewPostVideosVideoFileIdKodiRequestWithBody generates requests for PostVideosVideoFileIdKodi with any type of body
func NewPostVideosVideoFileIdKodiRequestWithBody(server string, videoFileId PathVideoFileId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "videoFileId", runtime.ParamLocationPath, videoFileId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/videos/%s/kodi", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetVideosVideoFileIdPlaylistRequest generates requests for GetVideosVideoFileIdPlaylist
func NewGetVideosVideoFileIdPlaylistRequest(server string, videoFileId PathVideoFileId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "videoFileId", runtime.ParamLocationPath, videoFileId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/videos/%s/playlist", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetChannelsWithResponse request
	GetChannelsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetChannelsResponse, error)

	// GetChannelsChannelIdLogoWithResponse request
	GetChannelsChannelIdLogoWithResponse(ctx context.Context, channelId PathChannelId, reqEditors ...RequestEditorFn) (*GetChannelsChannelIdLogoResponse, error)

	// GetConfigWithResponse request
	GetConfigWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetConfigResponse, error)

	// GetDropLogsDropLogFileIdWithResponse request
	GetDropLogsDropLogFileIdWithResponse(ctx context.Context, dropLogFileId PathDropLogFileId, params *GetDropLogsDropLogFileIdParams, reqEditors ...RequestEditorFn) (*GetDropLogsDropLogFileIdResponse, error)

	// GetEncodeWithResponse request
	GetEncodeWithResponse(ctx context.Context, params *GetEncodeParams, reqEditors ...RequestEditorFn) (*GetEncodeResponse, error)

	// PostEncodeWithBodyWithResponse request with any body
	PostEncodeWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostEncodeResponse, error)

	PostEncodeWithResponse(ctx context.Context, body PostEncodeJSONRequestBody, reqEditors ...RequestEditorFn) (*PostEncodeResponse, error)

	// DeleteEncodeEncodeIdWithResponse request
	DeleteEncodeEncodeIdWithResponse(ctx context.Context, encodeId PathEncodeId, reqEditors ...RequestEditorFn) (*DeleteEncodeEncodeIdResponse, error)

	// GetIptvChannelM3u8WithResponse request
	GetIptvChannelM3u8WithResponse(ctx context.Context, params *GetIptvChannelM3u8Params, reqEditors ...RequestEditorFn) (*GetIptvChannelM3u8Response, error)

	// GetIptvEpgXmlWithResponse request
	GetIptvEpgXmlWithResponse(ctx context.Context, params *GetIptvEpgXmlParams, reqEditors ...RequestEditorFn) (*GetIptvEpgXmlResponse, error)

	// GetRecordedWithResponse request
	GetRecordedWithResponse(ctx context.Context, params *GetRecordedParams, reqEditors ...RequestEditorFn) (*GetRecordedResponse, error)

	// PostRecordedWithBodyWithResponse request with any body
	PostRecordedWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostRecordedResponse, error)

	PostRecordedWithResponse(ctx context.Context, body PostRecordedJSONRequestBody, reqEditors ...RequestEditorFn) (*PostRecordedResponse, error)

	// PostRecordedCleanupWithResponse request
	PostRecordedCleanupWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PostRecordedCleanupResponse, error)

	// GetRecordedOptionsWithResponse request
	GetRecordedOptionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetRecordedOptionsResponse, error)

	// DeleteRecordedRecordedIdWithResponse request
	DeleteRecordedRecordedIdWithResponse(ctx context.Context, recordedId PathRecordedId, reqEditors ...RequestEditorFn) (*DeleteRecordedRecordedIdResponse, error)

	// GetRecordedRecordedIdWithResponse request
	GetRecordedRecordedIdWithResponse(ctx context.Context, recordedId PathRecordedId, params *GetRecordedRecordedIdParams, reqEditors ...RequestEditorFn) (*GetRecordedRecordedIdResponse, error)

	// DeleteRecordedRecordedIdEncodeWithResponse request
	DeleteRecordedRecordedIdEncodeWithResponse(ctx context.Context, recordedId PathRecordedId, reqEditors ...RequestEditorFn) (*DeleteRecordedRecordedIdEncodeResponse, error)

	// PutRecordedRecordedIdProtectWithResponse request
	PutRecordedRecordedIdProtectWithResponse(ctx context.Context, recordedId PathRecordedId, reqEditors ...RequestEditorFn) (*PutRecordedRecordedIdProtectResponse, error)

	// PutRecordedRecordedIdUnprotectWithResponse request
	PutRecordedRecordedIdUnprotectWithResponse(ctx context.Context, recordedId PathRecordedId, reqEditors ...RequestEditorFn) (*PutRecordedRecordedIdUnprotectResponse, error)

	// GetRecordingWithResponse request
	GetRecordingWithResponse(ctx context.Context, params *GetRecordingParams, reqEditors ...RequestEditorFn) (*GetRecordingResponse, error)

	// PostRecordingResettimerWithResponse request
	PostRecordingResettimerWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PostRecordingResettimerResponse, error)

	// GetReservesWithResponse request
	GetReservesWithResponse(ctx context.Context, params *GetReservesParams, reqEditors ...RequestEditorFn) (*GetReservesResponse, error)

	// PostReservesWithBodyWithResponse request with any body
	PostReservesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostReservesResponse, error)

	PostReservesWithResponse(ctx context.Context, body PostReservesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostReservesResponse, error)

	// GetReservesCntsWithResponse request
	GetReservesCntsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetReservesCntsResponse, error)

	// GetReservesListsWithResponse request
	GetReservesListsWithResponse(ctx context.Context, params *GetReservesListsParams, reqEditors ...RequestEditorFn) (*GetReservesListsResponse, error)

	// PostReservesUpdateWithResponse request
	PostReservesUpdateWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PostReservesUpdateResponse, error)

	// DeleteReservesReserveIdWithResponse request
	DeleteReservesReserveIdWithResponse(ctx context.Context, reserveId PathReserveId, reqEditors ...RequestEditorFn) (*DeleteReservesReserveIdResponse, error)

	// GetReservesReserveIdWithResponse request
	GetReservesReserveIdWithResponse(ctx context.Context, reserveId PathReserveId, params *GetReservesReserveIdParams, reqEditors ...RequestEditorFn) (*GetReservesReserveIdResponse, error)

	// PutReservesReserveIdWithBodyWithResponse request with any body
	PutReservesReserveIdWithBodyWithResponse(ctx context.Context, reserveId PathReserveId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutReservesReserveIdResponse, error)

	PutReservesReserveIdWithResponse(ctx context.Context, reserveId PathReserveId, body PutReservesReserveIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PutReservesReserveIdResponse, error)

	// DeleteReservesReserveIdOverlapWithResponse request
	DeleteReservesReserveIdOverlapWithResponse(ctx context.Context, reserveId PathReserveId, reqEditors ...RequestEditorFn) (*DeleteReservesReserveIdOverlapResponse, error)

	// DeleteReservesReserveIdSkipWithResponse request
	DeleteReservesReserveIdSkipWithResponse(ctx context.Context, reserveId PathReserveId, reqEditors ...RequestEditorFn) (*DeleteReservesReserveIdSkipResponse, error)

	// GetRulesWithResponse request
	GetRulesWithResponse(ctx context.Context, params *GetRulesParams, reqEditors ...RequestEditorFn) (*GetRulesResponse, error)

	// PostRulesWithBodyWithResponse request with any body
	PostRulesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostRulesResponse, error)

	PostRulesWithResponse(ctx context.Context, body PostRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostRulesResponse, error)

	// GetRulesKeywordWithResponse request
	GetRulesKeywordWithResponse(ctx context.Context, params *GetRulesKeywordParams, reqEditors ...RequestEditorFn) (*GetRulesKeywordResponse, error)

	// PostRulesKeywordWithBodyWithResponse request with any body
	PostRulesKeywordWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostRulesKeywordResponse, error)

	PostRulesKeywordWithResponse(ctx context.Context, body PostRulesKeywordJSONRequestBody, reqEditors ...RequestEditorFn) (*PostRulesKeywordResponse, error)

	// DeleteRulesRuleIdWithResponse request
	DeleteRulesRuleIdWithResponse(ctx context.Context, ruleId PathRuleId, reqEditors ...RequestEditorFn) (*DeleteRulesRuleIdResponse, error)

	// GetRulesRuleIdWithResponse request
	GetRulesRuleIdWithResponse(ctx context.Context, ruleId PathRuleId, reqEditors ...RequestEditorFn) (*GetRulesRuleIdResponse, error)

	// PutRulesRuleIdWithBodyWithResponse request with any body
	PutRulesRuleIdWithBodyWithResponse(ctx context.Context, ruleId PathRuleId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutRulesRuleIdResponse, error)

	PutRulesRuleIdWithResponse(ctx context.Context, ruleId PathRuleId, body PutRulesRuleIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PutRulesRuleIdResponse, error)

	// PutRulesRuleIdDisableWithResponse request
	PutRulesRuleIdDisableWithResponse(ctx context.Context, ruleId PathRuleId, reqEditors ...RequestEditorFn) (*PutRulesRuleIdDisableResponse, error)

	// PutRulesRuleIdEnableWithResponse request
	PutRulesRuleIdEnableWithResponse(ctx context.Context, ruleId PathRuleId, reqEditors ...RequestEditorFn) (*PutRulesRuleIdEnableResponse, error)

	// GetSchedulesWithResponse request
	GetSchedulesWithResponse(ctx context.Context, params *GetSchedulesParams, reqEditors ...RequestEditorFn) (*GetSchedulesResponse, error)

	// GetSchedulesBroadcastingWithResponse request
	GetSchedulesBroadcastingWithResponse(ctx context.Context, params *GetSchedulesBroadcastingParams, reqEditors ...RequestEditorFn) (*GetSchedulesBroadcastingResponse, error)

	// GetSchedulesDetailProgramIdWithResponse request
	GetSchedulesDetailProgramIdWithResponse(ctx context.Context, programId PathProgramId, params *GetSchedulesDetailProgramIdParams, reqEditors ...RequestEditorFn) (*GetSchedulesDetailProgramIdResponse, error)

	// PostSchedulesSearchWithBodyWithResponse request with any body
	PostSchedulesSearchWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSchedulesSearchResponse, error)

	PostSchedulesSearchWithResponse(ctx context.Context, body PostSchedulesSearchJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSchedulesSearchResponse, error)

	// GetSchedulesChannelIdWithResponse request
	GetSchedulesChannelIdWithResponse(ctx context.Context, channelId PathChannelId, params *GetSchedulesChannelIdParams, reqEditors ...RequestEditorFn) (*GetSchedulesChannelIdResponse, error)

	// GetStoragesWithResponse request
	GetStoragesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetStoragesResponse, error)

	// DeleteStreamsWithResponse request
	DeleteStreamsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DeleteStreamsResponse, error)

	// GetStreamsWithResponse request
	GetStreamsWithResponse(ctx context.Context, params *GetStreamsParams, reqEditors ...RequestEditorFn) (*GetStreamsResponse, error)

	// GetStreamsLiveChannelIdHlsWithResponse request
	GetStreamsLiveChannelIdHlsWithResponse(ctx context.Context, channelId PathChannelId, params *GetStreamsLiveChannelIdHlsParams, reqEditors ...RequestEditorFn) (*GetStreamsLiveChannelIdHlsResponse, error)

	// GetStreamsLiveChannelIdM2tsWithResponse request
	GetStreamsLiveChannelIdM2tsWithResponse(ctx context.Context, channelId PathChannelId, params *GetStreamsLiveChannelIdM2tsParams, reqEditors ...RequestEditorFn) (*GetStreamsLiveChannelIdM2tsResponse, error)

	// GetStreamsLiveChannelIdM2tsPlaylistWithResponse request
	GetStreamsLiveChannelIdM2tsPlaylistWithResponse(ctx context.Context, channelId PathChannelId, params *GetStreamsLiveChannelIdM2tsPlaylistParams, reqEditors ...RequestEditorFn) (*GetStreamsLiveChannelIdM2tsPlaylistResponse, error)

	// GetStreamsLiveChannelIdM2tsllWithResponse request
	GetStreamsLiveChannelIdM2tsllWithResponse(ctx context.Context, channelId PathChannelId, params *GetStreamsLiveChannelIdM2tsllParams, reqEditors ...RequestEditorFn) (*GetStreamsLiveChannelIdM2tsllResponse, error)

	// GetStreamsLiveChannelIdMp4WithResponse request
	GetStreamsLiveChannelIdMp4WithResponse(ctx context.Context, channelId PathChannelId, params *GetStreamsLiveChannelIdMp4Params, reqEditors ...RequestEditorFn) (*GetStreamsLiveChannelIdMp4Response, error)

	// GetStreamsLiveChannelIdWebmWithResponse request
	GetStreamsLiveChannelIdWebmWithResponse(ctx context.Context, channelId PathChannelId, params *GetStreamsLiveChannelIdWebmParams, reqEditors ...RequestEditorFn) (*GetStreamsLiveChannelIdWebmResponse, error)

	// GetStreamsRecordedVideoFileIdHlsWithResponse request
	GetStreamsRecordedVideoFileIdHlsWithResponse(ctx context.Context, videoFileId PathVideoFileId, params *GetStreamsRecordedVideoFileIdHlsParams, reqEditors ...RequestEditorFn) (*GetStreamsRecordedVideoFileIdHlsResponse, error)

	// GetStreamsRecordedVideoFileIdMp4WithResponse request
	GetStreamsRecordedVideoFileIdMp4WithResponse(ctx context.Context, videoFileId PathVideoFileId, params *GetStreamsRecordedVideoFileIdMp4Params, reqEditors ...RequestEditorFn) (*GetStreamsRecordedVideoFileIdMp4Response, error)

	// GetStreamsRecordedVideoFileIdWebmWithResponse request
	GetStreamsRecordedVideoFileIdWebmWithResponse(ctx context.Context, videoFileId PathVideoFileId, params *GetStreamsRecordedVideoFileIdWebmParams, reqEditors ...RequestEditorFn) (*GetStreamsRecordedVideoFileIdWebmResponse, error)

	// DeleteStreamsStreamIdWithResponse request
	DeleteStreamsStreamIdWithResponse(ctx context.Context, streamId PathStreamId, reqEditors ...RequestEditorFn) (*DeleteStreamsStreamIdResponse, error)

	// PutStreamsStreamIdKeepWithResponse request
	PutStreamsStreamIdKeepWithResponse(ctx context.Context, streamId PathStreamId, reqEditors ...RequestEditorFn) (*PutStreamsStreamIdKeepResponse, error)

	// GetTagsWithResponse request
	GetTagsWithResponse(ctx context.Context, params *GetTagsParams, reqEditors ...RequestEditorFn) (*GetTagsResponse, error)

	// PostTagsWithBodyWithResponse request with any body
	PostTagsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostTagsResponse, error)

	PostTagsWithResponse(ctx context.Context, body PostTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostTagsResponse, error)

	// DeleteTagsTagIdWithResponse request
	DeleteTagsTagIdWithResponse(ctx context.Context, tagId PathRecordedTagId, reqEditors ...RequestEditorFn) (*DeleteTagsTagIdResponse, error)

	// PutTagsTagIdWithBodyWithResponse request with any body
	PutTagsTagIdWithBodyWithResponse(ctx context.Context, tagId PathRecordedTagId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutTagsTagIdResponse, error)

	PutTagsTagIdWithResponse(ctx context.Context, tagId PathRecordedTagId, body PutTagsTagIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PutTagsTagIdResponse, error)

	// DeleteTagsTagIdRelateWithResponse request
	DeleteTagsTagIdRelateWithResponse(ctx context.Context, tagId PathRecordedTagId, params *DeleteTagsTagIdRelateParams, reqEditors ...RequestEditorFn) (*DeleteTagsTagIdRelateResponse, error)

	// PutTagsTagIdRelateWithBodyWithResponse request with any body
	PutTagsTagIdRelateWithBodyWithResponse(ctx context.Context, tagId PathRecordedTagId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutTagsTagIdRelateResponse, error)

	PutTagsTagIdRelateWithResponse(ctx context.Context, tagId PathRecordedTagId, body PutTagsTagIdRelateJSONRequestBody, reqEditors ...RequestEditorFn) (*PutTagsTagIdRelateResponse, error)

	// PostThumbnailsWithResponse request
	PostThumbnailsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PostThumbnailsResponse, error)

	// PostThumbnailsCleanupWithResponse request
	PostThumbnailsCleanupWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PostThumbnailsCleanupResponse, error)

	// GetThumbnailsThumbnailIdWithResponse request
	GetThumbnailsThumbnailIdWithResponse(ctx context.Context, thumbnailId PathThumbnailId, reqEditors ...RequestEditorFn) (*GetThumbnailsThumbnailIdResponse, error)

	// GetVersionWithResponse request
	GetVersionWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetVersionResponse, error)

	// PostVideosUploadWithBodyWithResponse request with any body
	PostVideosUploadWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostVideosUploadResponse, error)

	// DeleteVideosVideoFileIdWithResponse request
	DeleteVideosVideoFileIdWithResponse(ctx context.Context, videoFileId PathVideoFileId, reqEditors ...RequestEditorFn) (*DeleteVideosVideoFileIdResponse, error)

	// GetVideosVideoFileIdWithResponse request
	GetVideosVideoFileIdWithResponse(ctx context.Context, videoFileId PathVideoFileId, params *GetVideosVideoFileIdParams, reqEditors ...RequestEditorFn) (*GetVideosVideoFileIdResponse, error)

	// GetVideosVideoFileIdDurationWithResponse request
	GetVideosVideoFileIdDurationWithResponse(ctx context.Context, videoFileId PathVideoFileId, reqEditors ...RequestEditorFn) (*GetVideosVideoFileIdDurationResponse, error)

	// PostVideosVideoFileIdKodiWithBodyWithResponse request with any body
	PostVideosVideoFileIdKodiWithBodyWithResponse(ctx context.Context, videoFileId PathVideoFileId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostVideosVideoFileIdKodiResponse, error)

	PostVideosVideoFileIdKodiWithResponse(ctx context.Context, videoFileId PathVideoFileId, body PostVideosVideoFileIdKodiJSONRequestBody, reqEditors ...RequestEditorFn) (*PostVideosVideoFileIdKodiResponse, error)

	// GetVideosVideoFileIdPlaylistWithResponse request
	GetVideosVideoFileIdPlaylistWithResponse(ctx context.Context, videoFileId PathVideoFileId, reqEditors ...RequestEditorFn) (*GetVideosVideoFileIdPlaylistResponse, error)
}

type GetChannelsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ChannelItems
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetChannelsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetChannelsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetChannelsChannelIdLogoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetChannelsChannelIdLogoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetChannelsChannelIdLogoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetConfigResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Config
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDropLogsDropLogFileIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetDropLogsDropLogFileIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDropLogsDropLogFileIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEncodeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EncodeInfo
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetEncodeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEncodeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostEncodeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *AddedEncode
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PostEncodeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostEncodeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteEncodeEncodeIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DeleteEncodeEncodeIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteEncodeEncodeIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetIptvChannelM3u8Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetIptvChannelM3u8Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetIptvChannelM3u8Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetIptvEpgXmlResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetIptvEpgXmlResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetIptvEpgXmlResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRecordedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Records
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetRecordedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRecordedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostRecordedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *CreatedNewRecorded
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PostRecordedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostRecordedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostRecordedCleanupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PostRecordedCleanupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostRecordedCleanupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRecordedOptionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RecordedSearchOptions
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetRecordedOptionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRecordedOptionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteRecordedRecordedIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DeleteRecordedRecordedIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteRecordedRecordedIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRecordedRecordedIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RecordedItem
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetRecordedRecordedIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRecordedRecordedIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteRecordedRecordedIdEncodeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DeleteRecordedRecordedIdEncodeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteRecordedRecordedIdEncodeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutRecordedRecordedIdProtectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PutRecordedRecordedIdProtectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutRecordedRecordedIdProtectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutRecordedRecordedIdUnprotectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PutRecordedRecordedIdUnprotectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutRecordedRecordedIdUnprotectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRecordingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Records
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetRecordingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRecordingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostRecordingResettimerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PostRecordingResettimerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostRecordingResettimerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetReservesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Reserves
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetReservesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetReservesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostReservesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *AddedReserve
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PostReservesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostReservesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetReservesCntsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ReserveCnts
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetReservesCntsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetReservesCntsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetReservesListsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ReserveLists
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetReservesListsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetReservesListsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostReservesUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PostReservesUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostReservesUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteReservesReserveIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DeleteReservesReserveIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteReservesReserveIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetReservesReserveIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ReserveItem
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetReservesReserveIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetReservesReserveIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutReservesReserveIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PutReservesReserveIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutReservesReserveIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteReservesReserveIdOverlapResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DeleteReservesReserveIdOverlapResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteReservesReserveIdOverlapResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteReservesReserveIdSkipResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DeleteReservesReserveIdSkipResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteReservesReserveIdSkipResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRulesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Rules
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetRulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostRulesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *AddedRule
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PostRulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostRulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRulesKeywordResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RuleKeywordInfo
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetRulesKeywordResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRulesKeywordResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostRulesKeywordResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *AddedRule
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PostRulesKeywordResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostRulesKeywordResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteRulesRuleIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DeleteRulesRuleIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteRulesRuleIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRulesRuleIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Rule
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetRulesRuleIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRulesRuleIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutRulesRuleIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PutRulesRuleIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutRulesRuleIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutRulesRuleIdDisableResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PutRulesRuleIdDisableResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutRulesRuleIdDisableResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutRulesRuleIdEnableResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PutRulesRuleIdEnableResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutRulesRuleIdEnableResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSchedulesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Schedules
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetSchedulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSchedulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSchedulesBroadcastingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Schedules
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetSchedulesBroadcastingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSchedulesBroadcastingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSchedulesDetailProgramIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ScheduleProgramItem
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetSchedulesDetailProgramIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSchedulesDetailProgramIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostSchedulesSearchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ScheduleProgramItem
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PostSchedulesSearchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostSchedulesSearchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSchedulesChannelIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Schedules
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetSchedulesChannelIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSchedulesChannelIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStoragesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StorageInfo
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetStoragesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStoragesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteStreamsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DeleteStreamsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteStreamsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStreamsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StreamInfo
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetStreamsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStreamsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStreamsLiveChannelIdHlsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StartStreamInfo
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetStreamsLiveChannelIdHlsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStreamsLiveChannelIdHlsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStreamsLiveChannelIdM2tsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetStreamsLiveChannelIdM2tsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStreamsLiveChannelIdM2tsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStreamsLiveChannelIdM2tsPlaylistResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetStreamsLiveChannelIdM2tsPlaylistResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStreamsLiveChannelIdM2tsPlaylistResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStreamsLiveChannelIdM2tsllResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetStreamsLiveChannelIdM2tsllResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStreamsLiveChannelIdM2tsllResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStreamsLiveChannelIdMp4Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetStreamsLiveChannelIdMp4Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStreamsLiveChannelIdMp4Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStreamsLiveChannelIdWebmResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetStreamsLiveChannelIdWebmResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStreamsLiveChannelIdWebmResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStreamsRecordedVideoFileIdHlsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StartStreamInfo
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetStreamsRecordedVideoFileIdHlsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStreamsRecordedVideoFileIdHlsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStreamsRecordedVideoFileIdMp4Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetStreamsRecordedVideoFileIdMp4Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStreamsRecordedVideoFileIdMp4Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStreamsRecordedVideoFileIdWebmResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetStreamsRecordedVideoFileIdWebmResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStreamsRecordedVideoFileIdWebmResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteStreamsStreamIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DeleteStreamsStreamIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteStreamsStreamIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutStreamsStreamIdKeepResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PutStreamsStreamIdKeepResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutStreamsStreamIdKeepResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTagsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RecordedTags
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetTagsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTagsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostTagsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *AddedRecordedTag
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PostTagsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostTagsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteTagsTagIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DeleteTagsTagIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteTagsTagIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutTagsTagIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PutTagsTagIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutTagsTagIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteTagsTagIdRelateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DeleteTagsTagIdRelateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteTagsTagIdRelateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutTagsTagIdRelateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PutTagsTagIdRelateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutTagsTagIdRelateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostThumbnailsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PostThumbnailsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostThumbnailsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostThumbnailsCleanupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PostThumbnailsCleanupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostThumbnailsCleanupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetThumbnailsThumbnailIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetThumbnailsThumbnailIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetThumbnailsThumbnailIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVersionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Version
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetVersionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVersionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostVideosUploadResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PostVideosUploadResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostVideosUploadResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteVideosVideoFileIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DeleteVideosVideoFileIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteVideosVideoFileIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVideosVideoFileIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetVideosVideoFileIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVideosVideoFileIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVideosVideoFileIdDurationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VideoFileDuration
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetVideosVideoFileIdDurationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVideosVideoFileIdDurationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostVideosVideoFileIdKodiResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PostVideosVideoFileIdKodiResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostVideosVideoFileIdKodiResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVideosVideoFileIdPlaylistResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetVideosVideoFileIdPlaylistResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVideosVideoFileIdPlaylistResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetChannelsWithResponse request returning *GetChannelsResponse
func (c *ClientWithResponses) GetChannelsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetChannelsResponse, error) {
	rsp, err := c.GetChannels(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetChannelsResponse(rsp)
}

// GetChannelsChannelIdLogoWithResponse request returning *GetChannelsChannelIdLogoResponse
func (c *ClientWithResponses) GetChannelsChannelIdLogoWithResponse(ctx context.Context, channelId PathChannelId, reqEditors ...RequestEditorFn) (*GetChannelsChannelIdLogoResponse, error) {
	rsp, err := c.GetChannelsChannelIdLogo(ctx, channelId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetChannelsChannelIdLogoResponse(rsp)
}

// GetConfigWithResponse request returning *GetConfigResponse
func (c *ClientWithResponses) GetConfigWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetConfigResponse, error) {
	rsp, err := c.GetConfig(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetConfigResponse(rsp)
}

// GetDropLogsDropLogFileIdWithResponse request returning *GetDropLogsDropLogFileIdResponse
func (c *ClientWithResponses) GetDropLogsDropLogFileIdWithResponse(ctx context.Context, dropLogFileId PathDropLogFileId, params *GetDropLogsDropLogFileIdParams, reqEditors ...RequestEditorFn) (*GetDropLogsDropLogFileIdResponse, error) {
	rsp, err := c.GetDropLogsDropLogFileId(ctx, dropLogFileId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDropLogsDropLogFileIdResponse(rsp)
}

// GetEncodeWithResponse request returning *GetEncodeResponse
func (c *ClientWithResponses) GetEncodeWithResponse(ctx context.Context, params *GetEncodeParams, reqEditors ...RequestEditorFn) (*GetEncodeResponse, error) {
	rsp, err := c.GetEncode(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEncodeResponse(rsp)
}

// PostEncodeWithBodyWithResponse request with arbitrary body returning *PostEncodeResponse
func (c *ClientWithResponses) PostEncodeWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostEncodeResponse, error) {
	rsp, err := c.PostEncodeWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostEncodeResponse(rsp)
}

func (c *ClientWithResponses) PostEncodeWithResponse(ctx context.Context, body PostEncodeJSONRequestBody, reqEditors ...RequestEditorFn) (*PostEncodeResponse, error) {
	rsp, err := c.PostEncode(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostEncodeResponse(rsp)
}

// DeleteEncodeEncodeIdWithResponse request returning *DeleteEncodeEncodeIdResponse
func (c *ClientWithResponses) DeleteEncodeEncodeIdWithResponse(ctx context.Context, encodeId PathEncodeId, reqEditors ...RequestEditorFn) (*DeleteEncodeEncodeIdResponse, error) {
	rsp, err := c.DeleteEncodeEncodeId(ctx, encodeId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteEncodeEncodeIdResponse(rsp)
}

// GetIptvChannelM3u8WithResponse request returning *GetIptvChannelM3u8Response
func (c *ClientWithResponses) GetIptvChannelM3u8WithResponse(ctx context.Context, params *GetIptvChannelM3u8Params, reqEditors ...RequestEditorFn) (*GetIptvChannelM3u8Response, error) {
	rsp, err := c.GetIptvChannelM3u8(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetIptvChannelM3u8Response(rsp)
}

// GetIptvEpgXmlWithResponse request returning *GetIptvEpgXmlResponse
func (c *ClientWithResponses) GetIptvEpgXmlWithResponse(ctx context.Context, params *GetIptvEpgXmlParams, reqEditors ...RequestEditorFn) (*GetIptvEpgXmlResponse, error) {
	rsp, err := c.GetIptvEpgXml(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetIptvEpgXmlResponse(rsp)
}

// GetRecordedWithResponse request returning *GetRecordedResponse
func (c *ClientWithResponses) GetRecordedWithResponse(ctx context.Context, params *GetRecordedParams, reqEditors ...RequestEditorFn) (*GetRecordedResponse, error) {
	rsp, err := c.GetRecorded(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRecordedResponse(rsp)
}

// PostRecordedWithBodyWithResponse request with arbitrary body returning *PostRecordedResponse
func (c *ClientWithResponses) PostRecordedWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostRecordedResponse, error) {
	rsp, err := c.PostRecordedWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostRecordedResponse(rsp)
}

func (c *ClientWithResponses) PostRecordedWithResponse(ctx context.Context, body PostRecordedJSONRequestBody, reqEditors ...RequestEditorFn) (*PostRecordedResponse, error) {
	rsp, err := c.PostRecorded(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostRecordedResponse(rsp)
}

// PostRecordedCleanupWithResponse request returning *PostRecordedCleanupResponse
func (c *ClientWithResponses) PostRecordedCleanupWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PostRecordedCleanupResponse, error) {
	rsp, err := c.PostRecordedCleanup(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostRecordedCleanupResponse(rsp)
}

// GetRecordedOptionsWithResponse request returning *GetRecordedOptionsResponse
func (c *ClientWithResponses) GetRecordedOptionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetRecordedOptionsResponse, error) {
	rsp, err := c.GetRecordedOptions(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRecordedOptionsResponse(rsp)
}

// DeleteRecordedRecordedIdWithResponse request returning *DeleteRecordedRecordedIdResponse
func (c *ClientWithResponses) DeleteRecordedRecordedIdWithResponse(ctx context.Context, recordedId PathRecordedId, reqEditors ...RequestEditorFn) (*DeleteRecordedRecordedIdResponse, error) {
	rsp, err := c.DeleteRecordedRecordedId(ctx, recordedId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteRecordedRecordedIdResponse(rsp)
}

// GetRecordedRecordedIdWithResponse request returning *GetRecordedRecordedIdResponse
func (c *ClientWithResponses) GetRecordedRecordedIdWithResponse(ctx context.Context, recordedId PathRecordedId, params *GetRecordedRecordedIdParams, reqEditors ...RequestEditorFn) (*GetRecordedRecordedIdResponse, error) {
	rsp, err := c.GetRecordedRecordedId(ctx, recordedId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRecordedRecordedIdResponse(rsp)
}

// DeleteRecordedRecordedIdEncodeWithResponse request returning *DeleteRecordedRecordedIdEncodeResponse
func (c *ClientWithResponses) DeleteRecordedRecordedIdEncodeWithResponse(ctx context.Context, recordedId PathRecordedId, reqEditors ...RequestEditorFn) (*DeleteRecordedRecordedIdEncodeResponse, error) {
	rsp, err := c.DeleteRecordedRecordedIdEncode(ctx, recordedId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteRecordedRecordedIdEncodeResponse(rsp)
}

// PutRecordedRecordedIdProtectWithResponse request returning *PutRecordedRecordedIdProtectResponse
func (c *ClientWithResponses) PutRecordedRecordedIdProtectWithResponse(ctx context.Context, recordedId PathRecordedId, reqEditors ...RequestEditorFn) (*PutRecordedRecordedIdProtectResponse, error) {
	rsp, err := c.PutRecordedRecordedIdProtect(ctx, recordedId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutRecordedRecordedIdProtectResponse(rsp)
}

// PutRecordedRecordedIdUnprotectWithResponse request returning *PutRecordedRecordedIdUnprotectResponse
func (c *ClientWithResponses) PutRecordedRecordedIdUnprotectWithResponse(ctx context.Context, recordedId PathRecordedId, reqEditors ...RequestEditorFn) (*PutRecordedRecordedIdUnprotectResponse, error) {
	rsp, err := c.PutRecordedRecordedIdUnprotect(ctx, recordedId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutRecordedRecordedIdUnprotectResponse(rsp)
}

// GetRecordingWithResponse request returning *GetRecordingResponse
func (c *ClientWithResponses) GetRecordingWithResponse(ctx context.Context, params *GetRecordingParams, reqEditors ...RequestEditorFn) (*GetRecordingResponse, error) {
	rsp, err := c.GetRecording(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRecordingResponse(rsp)
}

// PostRecordingResettimerWithResponse request returning *PostRecordingResettimerResponse
func (c *ClientWithResponses) PostRecordingResettimerWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PostRecordingResettimerResponse, error) {
	rsp, err := c.PostRecordingResettimer(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostRecordingResettimerResponse(rsp)
}

// GetReservesWithResponse request returning *GetReservesResponse
func (c *ClientWithResponses) GetReservesWithResponse(ctx context.Context, params *GetReservesParams, reqEditors ...RequestEditorFn) (*GetReservesResponse, error) {
	rsp, err := c.GetReserves(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetReservesResponse(rsp)
}

// PostReservesWithBodyWithResponse request with arbitrary body returning *PostReservesResponse
func (c *ClientWithResponses) PostReservesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostReservesResponse, error) {
	rsp, err := c.PostReservesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostReservesResponse(rsp)
}

func (c *ClientWithResponses) PostReservesWithResponse(ctx context.Context, body PostReservesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostReservesResponse, error) {
	rsp, err := c.PostReserves(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostReservesResponse(rsp)
}

// GetReservesCntsWithResponse request returning *GetReservesCntsResponse
func (c *ClientWithResponses) GetReservesCntsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetReservesCntsResponse, error) {
	rsp, err := c.GetReservesCnts(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetReservesCntsResponse(rsp)
}

// GetReservesListsWithResponse request returning *GetReservesListsResponse
func (c *ClientWithResponses) GetReservesListsWithResponse(ctx context.Context, params *GetReservesListsParams, reqEditors ...RequestEditorFn) (*GetReservesListsResponse, error) {
	rsp, err := c.GetReservesLists(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetReservesListsResponse(rsp)
}

// PostReservesUpdateWithResponse request returning *PostReservesUpdateResponse
func (c *ClientWithResponses) PostReservesUpdateWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PostReservesUpdateResponse, error) {
	rsp, err := c.PostReservesUpdate(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostReservesUpdateResponse(rsp)
}

// DeleteReservesReserveIdWithResponse request returning *DeleteReservesReserveIdResponse
func (c *ClientWithResponses) DeleteReservesReserveIdWithResponse(ctx context.Context, reserveId PathReserveId, reqEditors ...RequestEditorFn) (*DeleteReservesReserveIdResponse, error) {
	rsp, err := c.DeleteReservesReserveId(ctx, reserveId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteReservesReserveIdResponse(rsp)
}

// GetReservesReserveIdWithResponse request returning *GetReservesReserveIdResponse
func (c *ClientWithResponses) GetReservesReserveIdWithResponse(ctx context.Context, reserveId PathReserveId, params *GetReservesReserveIdParams, reqEditors ...RequestEditorFn) (*GetReservesReserveIdResponse, error) {
	rsp, err := c.GetReservesReserveId(ctx, reserveId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetReservesReserveIdResponse(rsp)
}

// PutReservesReserveIdWithBodyWithResponse request with arbitrary body returning *PutReservesReserveIdResponse
func (c *ClientWithResponses) PutReservesReserveIdWithBodyWithResponse(ctx context.Context, reserveId PathReserveId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutReservesReserveIdResponse, error) {
	rsp, err := c.PutReservesReserveIdWithBody(ctx, reserveId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutReservesReserveIdResponse(rsp)
}

func (c *ClientWithResponses) PutReservesReserveIdWithResponse(ctx context.Context, reserveId PathReserveId, body PutReservesReserveIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PutReservesReserveIdResponse, error) {
	rsp, err := c.PutReservesReserveId(ctx, reserveId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutReservesReserveIdResponse(rsp)
}

// DeleteReservesReserveIdOverlapWithResponse request returning *DeleteReservesReserveIdOverlapResponse
func (c *ClientWithResponses) DeleteReservesReserveIdOverlapWithResponse(ctx context.Context, reserveId PathReserveId, reqEditors ...RequestEditorFn) (*DeleteReservesReserveIdOverlapResponse, error) {
	rsp, err := c.DeleteReservesReserveIdOverlap(ctx, reserveId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteReservesReserveIdOverlapResponse(rsp)
}

// DeleteReservesReserveIdSkipWithResponse request returning *DeleteReservesReserveIdSkipResponse
func (c *ClientWithResponses) DeleteReservesReserveIdSkipWithResponse(ctx context.Context, reserveId PathReserveId, reqEditors ...RequestEditorFn) (*DeleteReservesReserveIdSkipResponse, error) {
	rsp, err := c.DeleteReservesReserveIdSkip(ctx, reserveId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteReservesReserveIdSkipResponse(rsp)
}

// GetRulesWithResponse request returning *GetRulesResponse
func (c *ClientWithResponses) GetRulesWithResponse(ctx context.Context, params *GetRulesParams, reqEditors ...RequestEditorFn) (*GetRulesResponse, error) {
	rsp, err := c.GetRules(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRulesResponse(rsp)
}

// PostRulesWithBodyWithResponse request with arbitrary body returning *PostRulesResponse
func (c *ClientWithResponses) PostRulesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostRulesResponse, error) {
	rsp, err := c.PostRulesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostRulesResponse(rsp)
}

func (c *ClientWithResponses) PostRulesWithResponse(ctx context.Context, body PostRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostRulesResponse, error) {
	rsp, err := c.PostRules(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostRulesResponse(rsp)
}

// GetRulesKeywordWithResponse request returning *GetRulesKeywordResponse
func (c *ClientWithResponses) GetRulesKeywordWithResponse(ctx context.Context, params *GetRulesKeywordParams, reqEditors ...RequestEditorFn) (*GetRulesKeywordResponse, error) {
	rsp, err := c.GetRulesKeyword(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRulesKeywordResponse(rsp)
}

// PostRulesKeywordWithBodyWithResponse request with arbitrary body returning *PostRulesKeywordResponse
func (c *ClientWithResponses) PostRulesKeywordWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostRulesKeywordResponse, error) {
	rsp, err := c.PostRulesKeywordWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostRulesKeywordResponse(rsp)
}

func (c *ClientWithResponses) PostRulesKeywordWithResponse(ctx context.Context, body PostRulesKeywordJSONRequestBody, reqEditors ...RequestEditorFn) (*PostRulesKeywordResponse, error) {
	rsp, err := c.PostRulesKeyword(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostRulesKeywordResponse(rsp)
}

// DeleteRulesRuleIdWithResponse request returning *DeleteRulesRuleIdResponse
func (c *ClientWithResponses) DeleteRulesRuleIdWithResponse(ctx context.Context, ruleId PathRuleId, reqEditors ...RequestEditorFn) (*DeleteRulesRuleIdResponse, error) {
	rsp, err := c.DeleteRulesRuleId(ctx, ruleId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteRulesRuleIdResponse(rsp)
}

// GetRulesRuleIdWithResponse request returning *GetRulesRuleIdResponse
func (c *ClientWithResponses) GetRulesRuleIdWithResponse(ctx context.Context, ruleId PathRuleId, reqEditors ...RequestEditorFn) (*GetRulesRuleIdResponse, error) {
	rsp, err := c.GetRulesRuleId(ctx, ruleId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRulesRuleIdResponse(rsp)
}

// PutRulesRuleIdWithBodyWithResponse request with arbitrary body returning *PutRulesRuleIdResponse
func (c *ClientWithResponses) PutRulesRuleIdWithBodyWithResponse(ctx context.Context, ruleId PathRuleId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutRulesRuleIdResponse, error) {
	rsp, err := c.PutRulesRuleIdWithBody(ctx, ruleId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutRulesRuleIdResponse(rsp)
}

func (c *ClientWithResponses) PutRulesRuleIdWithResponse(ctx context.Context, ruleId PathRuleId, body PutRulesRuleIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PutRulesRuleIdResponse, error) {
	rsp, err := c.PutRulesRuleId(ctx, ruleId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutRulesRuleIdResponse(rsp)
}

// PutRulesRuleIdDisableWithResponse request returning *PutRulesRuleIdDisableResponse
func (c *ClientWithResponses) PutRulesRuleIdDisableWithResponse(ctx context.Context, ruleId PathRuleId, reqEditors ...RequestEditorFn) (*PutRulesRuleIdDisableResponse, error) {
	rsp, err := c.PutRulesRuleIdDisable(ctx, ruleId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutRulesRuleIdDisableResponse(rsp)
}

// PutRulesRuleIdEnableWithResponse request returning *PutRulesRuleIdEnableResponse
func (c *ClientWithResponses) PutRulesRuleIdEnableWithResponse(ctx context.Context, ruleId PathRuleId, reqEditors ...RequestEditorFn) (*PutRulesRuleIdEnableResponse, error) {
	rsp, err := c.PutRulesRuleIdEnable(ctx, ruleId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutRulesRuleIdEnableResponse(rsp)
}

// GetSchedulesWithResponse request returning *GetSchedulesResponse
func (c *ClientWithResponses) GetSchedulesWithResponse(ctx context.Context, params *GetSchedulesParams, reqEditors ...RequestEditorFn) (*GetSchedulesResponse, error) {
	rsp, err := c.GetSchedules(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSchedulesResponse(rsp)
}

// GetSchedulesBroadcastingWithResponse request returning *GetSchedulesBroadcastingResponse
func (c *ClientWithResponses) GetSchedulesBroadcastingWithResponse(ctx context.Context, params *GetSchedulesBroadcastingParams, reqEditors ...RequestEditorFn) (*GetSchedulesBroadcastingResponse, error) {
	rsp, err := c.GetSchedulesBroadcasting(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSchedulesBroadcastingResponse(rsp)
}

// GetSchedulesDetailProgramIdWithResponse request returning *GetSchedulesDetailProgramIdResponse
func (c *ClientWithResponses) GetSchedulesDetailProgramIdWithResponse(ctx context.Context, programId PathProgramId, params *GetSchedulesDetailProgramIdParams, reqEditors ...RequestEditorFn) (*GetSchedulesDetailProgramIdResponse, error) {
	rsp, err := c.GetSchedulesDetailProgramId(ctx, programId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSchedulesDetailProgramIdResponse(rsp)
}

// PostSchedulesSearchWithBodyWithResponse request with arbitrary body returning *PostSchedulesSearchResponse
func (c *ClientWithResponses) PostSchedulesSearchWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSchedulesSearchResponse, error) {
	rsp, err := c.PostSchedulesSearchWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSchedulesSearchResponse(rsp)
}

func (c *ClientWithResponses) PostSchedulesSearchWithResponse(ctx context.Context, body PostSchedulesSearchJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSchedulesSearchResponse, error) {
	rsp, err := c.PostSchedulesSearch(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSchedulesSearchResponse(rsp)
}

// GetSchedulesChannelIdWithResponse request returning *GetSchedulesChannelIdResponse
func (c *ClientWithResponses) GetSchedulesChannelIdWithResponse(ctx context.Context, channelId PathChannelId, params *GetSchedulesChannelIdParams, reqEditors ...RequestEditorFn) (*GetSchedulesChannelIdResponse, error) {
	rsp, err := c.GetSchedulesChannelId(ctx, channelId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSchedulesChannelIdResponse(rsp)
}

// GetStoragesWithResponse request returning *GetStoragesResponse
func (c *ClientWithResponses) GetStoragesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetStoragesResponse, error) {
	rsp, err := c.GetStorages(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStoragesResponse(rsp)
}

// DeleteStreamsWithResponse request returning *DeleteStreamsResponse
func (c *ClientWithResponses) DeleteStreamsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DeleteStreamsResponse, error) {
	rsp, err := c.DeleteStreams(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteStreamsResponse(rsp)
}

// GetStreamsWithResponse request returning *GetStreamsResponse
func (c *ClientWithResponses) GetStreamsWithResponse(ctx context.Context, params *GetStreamsParams, reqEditors ...RequestEditorFn) (*GetStreamsResponse, error) {
	rsp, err := c.GetStreams(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStreamsResponse(rsp)
}

// GetStreamsLiveChannelIdHlsWithResponse request returning *GetStreamsLiveChannelIdHlsResponse
func (c *ClientWithResponses) GetStreamsLiveChannelIdHlsWithResponse(ctx context.Context, channelId PathChannelId, params *GetStreamsLiveChannelIdHlsParams, reqEditors ...RequestEditorFn) (*GetStreamsLiveChannelIdHlsResponse, error) {
	rsp, err := c.GetStreamsLiveChannelIdHls(ctx, channelId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStreamsLiveChannelIdHlsResponse(rsp)
}

// GetStreamsLiveChannelIdM2tsWithResponse request returning *GetStreamsLiveChannelIdM2tsResponse
func (c *ClientWithResponses) GetStreamsLiveChannelIdM2tsWithResponse(ctx context.Context, channelId PathChannelId, params *GetStreamsLiveChannelIdM2tsParams, reqEditors ...RequestEditorFn) (*GetStreamsLiveChannelIdM2tsResponse, error) {
	rsp, err := c.GetStreamsLiveChannelIdM2ts(ctx, channelId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStreamsLiveChannelIdM2tsResponse(rsp)
}

// GetStreamsLiveChannelIdM2tsPlaylistWithResponse request returning *GetStreamsLiveChannelIdM2tsPlaylistResponse
func (c *ClientWithResponses) GetStreamsLiveChannelIdM2tsPlaylistWithResponse(ctx context.Context, channelId PathChannelId, params *GetStreamsLiveChannelIdM2tsPlaylistParams, reqEditors ...RequestEditorFn) (*GetStreamsLiveChannelIdM2tsPlaylistResponse, error) {
	rsp, err := c.GetStreamsLiveChannelIdM2tsPlaylist(ctx, channelId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStreamsLiveChannelIdM2tsPlaylistResponse(rsp)
}

// GetStreamsLiveChannelIdM2tsllWithResponse request returning *GetStreamsLiveChannelIdM2tsllResponse
func (c *ClientWithResponses) GetStreamsLiveChannelIdM2tsllWithResponse(ctx context.Context, channelId PathChannelId, params *GetStreamsLiveChannelIdM2tsllParams, reqEditors ...RequestEditorFn) (*GetStreamsLiveChannelIdM2tsllResponse, error) {
	rsp, err := c.GetStreamsLiveChannelIdM2tsll(ctx, channelId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStreamsLiveChannelIdM2tsllResponse(rsp)
}

// GetStreamsLiveChannelIdMp4WithResponse request returning *GetStreamsLiveChannelIdMp4Response
func (c *ClientWithResponses) GetStreamsLiveChannelIdMp4WithResponse(ctx context.Context, channelId PathChannelId, params *GetStreamsLiveChannelIdMp4Params, reqEditors ...RequestEditorFn) (*GetStreamsLiveChannelIdMp4Response, error) {
	rsp, err := c.GetStreamsLiveChannelIdMp4(ctx, channelId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStreamsLiveChannelIdMp4Response(rsp)
}

// GetStreamsLiveChannelIdWebmWithResponse request returning *GetStreamsLiveChannelIdWebmResponse
func (c *ClientWithResponses) GetStreamsLiveChannelIdWebmWithResponse(ctx context.Context, channelId PathChannelId, params *GetStreamsLiveChannelIdWebmParams, reqEditors ...RequestEditorFn) (*GetStreamsLiveChannelIdWebmResponse, error) {
	rsp, err := c.GetStreamsLiveChannelIdWebm(ctx, channelId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStreamsLiveChannelIdWebmResponse(rsp)
}

// GetStreamsRecordedVideoFileIdHlsWithResponse request returning *GetStreamsRecordedVideoFileIdHlsResponse
func (c *ClientWithResponses) GetStreamsRecordedVideoFileIdHlsWithResponse(ctx context.Context, videoFileId PathVideoFileId, params *GetStreamsRecordedVideoFileIdHlsParams, reqEditors ...RequestEditorFn) (*GetStreamsRecordedVideoFileIdHlsResponse, error) {
	rsp, err := c.GetStreamsRecordedVideoFileIdHls(ctx, videoFileId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStreamsRecordedVideoFileIdHlsResponse(rsp)
}

// GetStreamsRecordedVideoFileIdMp4WithResponse request returning *GetStreamsRecordedVideoFileIdMp4Response
func (c *ClientWithResponses) GetStreamsRecordedVideoFileIdMp4WithResponse(ctx context.Context, videoFileId PathVideoFileId, params *GetStreamsRecordedVideoFileIdMp4Params, reqEditors ...RequestEditorFn) (*GetStreamsRecordedVideoFileIdMp4Response, error) {
	rsp, err := c.GetStreamsRecordedVideoFileIdMp4(ctx, videoFileId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStreamsRecordedVideoFileIdMp4Response(rsp)
}

// GetStreamsRecordedVideoFileIdWebmWithResponse request returning *GetStreamsRecordedVideoFileIdWebmResponse
func (c *ClientWithResponses) GetStreamsRecordedVideoFileIdWebmWithResponse(ctx context.Context, videoFileId PathVideoFileId, params *GetStreamsRecordedVideoFileIdWebmParams, reqEditors ...RequestEditorFn) (*GetStreamsRecordedVideoFileIdWebmResponse, error) {
	rsp, err := c.GetStreamsRecordedVideoFileIdWebm(ctx, videoFileId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStreamsRecordedVideoFileIdWebmResponse(rsp)
}

// DeleteStreamsStreamIdWithResponse request returning *DeleteStreamsStreamIdResponse
func (c *ClientWithResponses) DeleteStreamsStreamIdWithResponse(ctx context.Context, streamId PathStreamId, reqEditors ...RequestEditorFn) (*DeleteStreamsStreamIdResponse, error) {
	rsp, err := c.DeleteStreamsStreamId(ctx, streamId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteStreamsStreamIdResponse(rsp)
}

// PutStreamsStreamIdKeepWithResponse request returning *PutStreamsStreamIdKeepResponse
func (c *ClientWithResponses) PutStreamsStreamIdKeepWithResponse(ctx context.Context, streamId PathStreamId, reqEditors ...RequestEditorFn) (*PutStreamsStreamIdKeepResponse, error) {
	rsp, err := c.PutStreamsStreamIdKeep(ctx, streamId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutStreamsStreamIdKeepResponse(rsp)
}

// GetTagsWithResponse request returning *GetTagsResponse
func (c *ClientWithResponses) GetTagsWithResponse(ctx context.Context, params *GetTagsParams, reqEditors ...RequestEditorFn) (*GetTagsResponse, error) {
	rsp, err := c.GetTags(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTagsResponse(rsp)
}

// PostTagsWithBodyWithResponse request with arbitrary body returning *PostTagsResponse
func (c *ClientWithResponses) PostTagsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostTagsResponse, error) {
	rsp, err := c.PostTagsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostTagsResponse(rsp)
}

func (c *ClientWithResponses) PostTagsWithResponse(ctx context.Context, body PostTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostTagsResponse, error) {
	rsp, err := c.PostTags(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostTagsResponse(rsp)
}

// DeleteTagsTagIdWithResponse request returning *DeleteTagsTagIdResponse
func (c *ClientWithResponses) DeleteTagsTagIdWithResponse(ctx context.Context, tagId PathRecordedTagId, reqEditors ...RequestEditorFn) (*DeleteTagsTagIdResponse, error) {
	rsp, err := c.DeleteTagsTagId(ctx, tagId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTagsTagIdResponse(rsp)
}

// PutTagsTagIdWithBodyWithResponse request with arbitrary body returning *PutTagsTagIdResponse
func (c *ClientWithResponses) PutTagsTagIdWithBodyWithResponse(ctx context.Context, tagId PathRecordedTagId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutTagsTagIdResponse, error) {
	rsp, err := c.PutTagsTagIdWithBody(ctx, tagId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutTagsTagIdResponse(rsp)
}

func (c *ClientWithResponses) PutTagsTagIdWithResponse(ctx context.Context, tagId PathRecordedTagId, body PutTagsTagIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PutTagsTagIdResponse, error) {
	rsp, err := c.PutTagsTagId(ctx, tagId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutTagsTagIdResponse(rsp)
}

// DeleteTagsTagIdRelateWithResponse request returning *DeleteTagsTagIdRelateResponse
func (c *ClientWithResponses) DeleteTagsTagIdRelateWithResponse(ctx context.Context, tagId PathRecordedTagId, params *DeleteTagsTagIdRelateParams, reqEditors ...RequestEditorFn) (*DeleteTagsTagIdRelateResponse, error) {
	rsp, err := c.DeleteTagsTagIdRelate(ctx, tagId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTagsTagIdRelateResponse(rsp)
}

// PutTagsTagIdRelateWithBodyWithResponse request with arbitrary body returning *PutTagsTagIdRelateResponse
func (c *ClientWithResponses) PutTagsTagIdRelateWithBodyWithResponse(ctx context.Context, tagId PathRecordedTagId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutTagsTagIdRelateResponse, error) {
	rsp, err := c.PutTagsTagIdRelateWithBody(ctx, tagId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutTagsTagIdRelateResponse(rsp)
}

func (c *ClientWithResponses) PutTagsTagIdRelateWithResponse(ctx context.Context, tagId PathRecordedTagId, body PutTagsTagIdRelateJSONRequestBody, reqEditors ...RequestEditorFn) (*PutTagsTagIdRelateResponse, error) {
	rsp, err := c.PutTagsTagIdRelate(ctx, tagId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutTagsTagIdRelateResponse(rsp)
}

// PostThumbnailsWithResponse request returning *PostThumbnailsResponse
func (c *ClientWithResponses) PostThumbnailsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PostThumbnailsResponse, error) {
	rsp, err := c.PostThumbnails(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostThumbnailsResponse(rsp)
}

// PostThumbnailsCleanupWithResponse request returning *PostThumbnailsCleanupResponse
func (c *ClientWithResponses) PostThumbnailsCleanupWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PostThumbnailsCleanupResponse, error) {
	rsp, err := c.PostThumbnailsCleanup(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostThumbnailsCleanupResponse(rsp)
}

// GetThumbnailsThumbnailIdWithResponse request returning *GetThumbnailsThumbnailIdResponse
func (c *ClientWithResponses) GetThumbnailsThumbnailIdWithResponse(ctx context.Context, thumbnailId PathThumbnailId, reqEditors ...RequestEditorFn) (*GetThumbnailsThumbnailIdResponse, error) {
	rsp, err := c.GetThumbnailsThumbnailId(ctx, thumbnailId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetThumbnailsThumbnailIdResponse(rsp)
}

// GetVersionWithResponse request returning *GetVersionResponse
func (c *ClientWithResponses) GetVersionWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetVersionResponse, error) {
	rsp, err := c.GetVersion(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVersionResponse(rsp)
}

// PostVideosUploadWithBodyWithResponse request with arbitrary body returning *PostVideosUploadResponse
func (c *ClientWithResponses) PostVideosUploadWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostVideosUploadResponse, error) {
	rsp, err := c.PostVideosUploadWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostVideosUploadResponse(rsp)
}

// DeleteVideosVideoFileIdWithResponse request returning *DeleteVideosVideoFileIdResponse
func (c *ClientWithResponses) DeleteVideosVideoFileIdWithResponse(ctx context.Context, videoFileId PathVideoFileId, reqEditors ...RequestEditorFn) (*DeleteVideosVideoFileIdResponse, error) {
	rsp, err := c.DeleteVideosVideoFileId(ctx, videoFileId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteVideosVideoFileIdResponse(rsp)
}

// GetVideosVideoFileIdWithResponse request returning *GetVideosVideoFileIdResponse
func (c *ClientWithResponses) GetVideosVideoFileIdWithResponse(ctx context.Context, videoFileId PathVideoFileId, params *GetVideosVideoFileIdParams, reqEditors ...RequestEditorFn) (*GetVideosVideoFileIdResponse, error) {
	rsp, err := c.GetVideosVideoFileId(ctx, videoFileId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVideosVideoFileIdResponse(rsp)
}

// GetVideosVideoFileIdDurationWithResponse request returning *GetVideosVideoFileIdDurationResponse
func (c *ClientWithResponses) GetVideosVideoFileIdDurationWithResponse(ctx context.Context, videoFileId PathVideoFileId, reqEditors ...RequestEditorFn) (*GetVideosVideoFileIdDurationResponse, error) {
	rsp, err := c.GetVideosVideoFileIdDuration(ctx, videoFileId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVideosVideoFileIdDurationResponse(rsp)
}

// PostVideosVideoFileIdKodiWithBodyWithResponse request with arbitrary body returning *PostVideosVideoFileIdKodiResponse
func (c *ClientWithResponses) PostVideosVideoFileIdKodiWithBodyWithResponse(ctx context.Context, videoFileId PathVideoFileId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostVideosVideoFileIdKodiResponse, error) {
	rsp, err := c.PostVideosVideoFileIdKodiWithBody(ctx, videoFileId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostVideosVideoFileIdKodiResponse(rsp)
}

func (c *ClientWithResponses) PostVideosVideoFileIdKodiWithResponse(ctx context.Context, videoFileId PathVideoFileId, body PostVideosVideoFileIdKodiJSONRequestBody, reqEditors ...RequestEditorFn) (*PostVideosVideoFileIdKodiResponse, error) {
	rsp, err := c.PostVideosVideoFileIdKodi(ctx, videoFileId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostVideosVideoFileIdKodiResponse(rsp)
}

// GetVideosVideoFileIdPlaylistWithResponse request returning *GetVideosVideoFileIdPlaylistResponse
func (c *ClientWithResponses) GetVideosVideoFileIdPlaylistWithResponse(ctx context.Context, videoFileId PathVideoFileId, reqEditors ...RequestEditorFn) (*GetVideosVideoFileIdPlaylistResponse, error) {
	rsp, err := c.GetVideosVideoFileIdPlaylist(ctx, videoFileId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVideosVideoFileIdPlaylistResponse(rsp)
}

// ParseGetChannelsResponse parses an HTTP response from a GetChannelsWithResponse call
func ParseGetChannelsResponse(rsp *http.Response) (*GetChannelsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetChannelsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ChannelItems
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetChannelsChannelIdLogoResponse parses an HTTP response from a GetChannelsChannelIdLogoWithResponse call
func ParseGetChannelsChannelIdLogoResponse(rsp *http.Response) (*GetChannelsChannelIdLogoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetChannelsChannelIdLogoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetConfigResponse parses an HTTP response from a GetConfigWithResponse call
func ParseGetConfigResponse(rsp *http.Response) (*GetConfigResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Config
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetDropLogsDropLogFileIdResponse parses an HTTP response from a GetDropLogsDropLogFileIdWithResponse call
func ParseGetDropLogsDropLogFileIdResponse(rsp *http.Response) (*GetDropLogsDropLogFileIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDropLogsDropLogFileIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetEncodeResponse parses an HTTP response from a GetEncodeWithResponse call
func ParseGetEncodeResponse(rsp *http.Response) (*GetEncodeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEncodeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EncodeInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostEncodeResponse parses an HTTP response from a PostEncodeWithResponse call
func ParsePostEncodeResponse(rsp *http.Response) (*PostEncodeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostEncodeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest AddedEncode
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteEncodeEncodeIdResponse parses an HTTP response from a DeleteEncodeEncodeIdWithResponse call
func ParseDeleteEncodeEncodeIdResponse(rsp *http.Response) (*DeleteEncodeEncodeIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteEncodeEncodeIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetIptvChannelM3u8Response parses an HTTP response from a GetIptvChannelM3u8WithResponse call
func ParseGetIptvChannelM3u8Response(rsp *http.Response) (*GetIptvChannelM3u8Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetIptvChannelM3u8Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetIptvEpgXmlResponse parses an HTTP response from a GetIptvEpgXmlWithResponse call
func ParseGetIptvEpgXmlResponse(rsp *http.Response) (*GetIptvEpgXmlResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetIptvEpgXmlResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetRecordedResponse parses an HTTP response from a GetRecordedWithResponse call
func ParseGetRecordedResponse(rsp *http.Response) (*GetRecordedResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRecordedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Records
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostRecordedResponse parses an HTTP response from a PostRecordedWithResponse call
func ParsePostRecordedResponse(rsp *http.Response) (*PostRecordedResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostRecordedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreatedNewRecorded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostRecordedCleanupResponse parses an HTTP response from a PostRecordedCleanupWithResponse call
func ParsePostRecordedCleanupResponse(rsp *http.Response) (*PostRecordedCleanupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostRecordedCleanupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetRecordedOptionsResponse parses an HTTP response from a GetRecordedOptionsWithResponse call
func ParseGetRecordedOptionsResponse(rsp *http.Response) (*GetRecordedOptionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRecordedOptionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RecordedSearchOptions
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteRecordedRecordedIdResponse parses an HTTP response from a DeleteRecordedRecordedIdWithResponse call
func ParseDeleteRecordedRecordedIdResponse(rsp *http.Response) (*DeleteRecordedRecordedIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteRecordedRecordedIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetRecordedRecordedIdResponse parses an HTTP response from a GetRecordedRecordedIdWithResponse call
func ParseGetRecordedRecordedIdResponse(rsp *http.Response) (*GetRecordedRecordedIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRecordedRecordedIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RecordedItem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteRecordedRecordedIdEncodeResponse parses an HTTP response from a DeleteRecordedRecordedIdEncodeWithResponse call
func ParseDeleteRecordedRecordedIdEncodeResponse(rsp *http.Response) (*DeleteRecordedRecordedIdEncodeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteRecordedRecordedIdEncodeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePutRecordedRecordedIdProtectResponse parses an HTTP response from a PutRecordedRecordedIdProtectWithResponse call
func ParsePutRecordedRecordedIdProtectResponse(rsp *http.Response) (*PutRecordedRecordedIdProtectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutRecordedRecordedIdProtectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePutRecordedRecordedIdUnprotectResponse parses an HTTP response from a PutRecordedRecordedIdUnprotectWithResponse call
func ParsePutRecordedRecordedIdUnprotectResponse(rsp *http.Response) (*PutRecordedRecordedIdUnprotectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutRecordedRecordedIdUnprotectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetRecordingResponse parses an HTTP response from a GetRecordingWithResponse call
func ParseGetRecordingResponse(rsp *http.Response) (*GetRecordingResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRecordingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Records
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostRecordingResettimerResponse parses an HTTP response from a PostRecordingResettimerWithResponse call
func ParsePostRecordingResettimerResponse(rsp *http.Response) (*PostRecordingResettimerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostRecordingResettimerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetReservesResponse parses an HTTP response from a GetReservesWithResponse call
func ParseGetReservesResponse(rsp *http.Response) (*GetReservesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetReservesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Reserves
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostReservesResponse parses an HTTP response from a PostReservesWithResponse call
func ParsePostReservesResponse(rsp *http.Response) (*PostReservesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostReservesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest AddedReserve
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetReservesCntsResponse parses an HTTP response from a GetReservesCntsWithResponse call
func ParseGetReservesCntsResponse(rsp *http.Response) (*GetReservesCntsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetReservesCntsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReserveCnts
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetReservesListsResponse parses an HTTP response from a GetReservesListsWithResponse call
func ParseGetReservesListsResponse(rsp *http.Response) (*GetReservesListsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetReservesListsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReserveLists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostReservesUpdateResponse parses an HTTP response from a PostReservesUpdateWithResponse call
func ParsePostReservesUpdateResponse(rsp *http.Response) (*PostReservesUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostReservesUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteReservesReserveIdResponse parses an HTTP response from a DeleteReservesReserveIdWithResponse call
func ParseDeleteReservesReserveIdResponse(rsp *http.Response) (*DeleteReservesReserveIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteReservesReserveIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetReservesReserveIdResponse parses an HTTP response from a GetReservesReserveIdWithResponse call
func ParseGetReservesReserveIdResponse(rsp *http.Response) (*GetReservesReserveIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetReservesReserveIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReserveItem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePutReservesReserveIdResponse parses an HTTP response from a PutReservesReserveIdWithResponse call
func ParsePutReservesReserveIdResponse(rsp *http.Response) (*PutReservesReserveIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutReservesReserveIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteReservesReserveIdOverlapResponse parses an HTTP response from a DeleteReservesReserveIdOverlapWithResponse call
func ParseDeleteReservesReserveIdOverlapResponse(rsp *http.Response) (*DeleteReservesReserveIdOverlapResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteReservesReserveIdOverlapResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteReservesReserveIdSkipResponse parses an HTTP response from a DeleteReservesReserveIdSkipWithResponse call
func ParseDeleteReservesReserveIdSkipResponse(rsp *http.Response) (*DeleteReservesReserveIdSkipResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteReservesReserveIdSkipResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetRulesResponse parses an HTTP response from a GetRulesWithResponse call
func ParseGetRulesResponse(rsp *http.Response) (*GetRulesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Rules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostRulesResponse parses an HTTP response from a PostRulesWithResponse call
func ParsePostRulesResponse(rsp *http.Response) (*PostRulesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostRulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest AddedRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetRulesKeywordResponse parses an HTTP response from a GetRulesKeywordWithResponse call
func ParseGetRulesKeywordResponse(rsp *http.Response) (*GetRulesKeywordResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRulesKeywordResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RuleKeywordInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostRulesKeywordResponse parses an HTTP response from a PostRulesKeywordWithResponse call
func ParsePostRulesKeywordResponse(rsp *http.Response) (*PostRulesKeywordResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostRulesKeywordResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest AddedRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteRulesRuleIdResponse parses an HTTP response from a DeleteRulesRuleIdWithResponse call
func ParseDeleteRulesRuleIdResponse(rsp *http.Response) (*DeleteRulesRuleIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteRulesRuleIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetRulesRuleIdResponse parses an HTTP response from a GetRulesRuleIdWithResponse call
func ParseGetRulesRuleIdResponse(rsp *http.Response) (*GetRulesRuleIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRulesRuleIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Rule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePutRulesRuleIdResponse parses an HTTP response from a PutRulesRuleIdWithResponse call
func ParsePutRulesRuleIdResponse(rsp *http.Response) (*PutRulesRuleIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutRulesRuleIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePutRulesRuleIdDisableResponse parses an HTTP response from a PutRulesRuleIdDisableWithResponse call
func ParsePutRulesRuleIdDisableResponse(rsp *http.Response) (*PutRulesRuleIdDisableResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutRulesRuleIdDisableResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePutRulesRuleIdEnableResponse parses an HTTP response from a PutRulesRuleIdEnableWithResponse call
func ParsePutRulesRuleIdEnableResponse(rsp *http.Response) (*PutRulesRuleIdEnableResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutRulesRuleIdEnableResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetSchedulesResponse parses an HTTP response from a GetSchedulesWithResponse call
func ParseGetSchedulesResponse(rsp *http.Response) (*GetSchedulesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSchedulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Schedules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetSchedulesBroadcastingResponse parses an HTTP response from a GetSchedulesBroadcastingWithResponse call
func ParseGetSchedulesBroadcastingResponse(rsp *http.Response) (*GetSchedulesBroadcastingResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSchedulesBroadcastingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Schedules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetSchedulesDetailProgramIdResponse parses an HTTP response from a GetSchedulesDetailProgramIdWithResponse call
func ParseGetSchedulesDetailProgramIdResponse(rsp *http.Response) (*GetSchedulesDetailProgramIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSchedulesDetailProgramIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ScheduleProgramItem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostSchedulesSearchResponse parses an HTTP response from a PostSchedulesSearchWithResponse call
func ParsePostSchedulesSearchResponse(rsp *http.Response) (*PostSchedulesSearchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostSchedulesSearchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ScheduleProgramItem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetSchedulesChannelIdResponse parses an HTTP response from a GetSchedulesChannelIdWithResponse call
func ParseGetSchedulesChannelIdResponse(rsp *http.Response) (*GetSchedulesChannelIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSchedulesChannelIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Schedules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetStoragesResponse parses an HTTP response from a GetStoragesWithResponse call
func ParseGetStoragesResponse(rsp *http.Response) (*GetStoragesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStoragesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StorageInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteStreamsResponse parses an HTTP response from a DeleteStreamsWithResponse call
func ParseDeleteStreamsResponse(rsp *http.Response) (*DeleteStreamsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteStreamsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetStreamsResponse parses an HTTP response from a GetStreamsWithResponse call
func ParseGetStreamsResponse(rsp *http.Response) (*GetStreamsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStreamsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StreamInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetStreamsLiveChannelIdHlsResponse parses an HTTP response from a GetStreamsLiveChannelIdHlsWithResponse call
func ParseGetStreamsLiveChannelIdHlsResponse(rsp *http.Response) (*GetStreamsLiveChannelIdHlsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStreamsLiveChannelIdHlsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StartStreamInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetStreamsLiveChannelIdM2tsResponse parses an HTTP response from a GetStreamsLiveChannelIdM2tsWithResponse call
func ParseGetStreamsLiveChannelIdM2tsResponse(rsp *http.Response) (*GetStreamsLiveChannelIdM2tsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStreamsLiveChannelIdM2tsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetStreamsLiveChannelIdM2tsPlaylistResponse parses an HTTP response from a GetStreamsLiveChannelIdM2tsPlaylistWithResponse call
func ParseGetStreamsLiveChannelIdM2tsPlaylistResponse(rsp *http.Response) (*GetStreamsLiveChannelIdM2tsPlaylistResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStreamsLiveChannelIdM2tsPlaylistResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetStreamsLiveChannelIdM2tsllResponse parses an HTTP response from a GetStreamsLiveChannelIdM2tsllWithResponse call
func ParseGetStreamsLiveChannelIdM2tsllResponse(rsp *http.Response) (*GetStreamsLiveChannelIdM2tsllResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStreamsLiveChannelIdM2tsllResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetStreamsLiveChannelIdMp4Response parses an HTTP response from a GetStreamsLiveChannelIdMp4WithResponse call
func ParseGetStreamsLiveChannelIdMp4Response(rsp *http.Response) (*GetStreamsLiveChannelIdMp4Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStreamsLiveChannelIdMp4Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetStreamsLiveChannelIdWebmResponse parses an HTTP response from a GetStreamsLiveChannelIdWebmWithResponse call
func ParseGetStreamsLiveChannelIdWebmResponse(rsp *http.Response) (*GetStreamsLiveChannelIdWebmResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStreamsLiveChannelIdWebmResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetStreamsRecordedVideoFileIdHlsResponse parses an HTTP response from a GetStreamsRecordedVideoFileIdHlsWithResponse call
func ParseGetStreamsRecordedVideoFileIdHlsResponse(rsp *http.Response) (*GetStreamsRecordedVideoFileIdHlsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStreamsRecordedVideoFileIdHlsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StartStreamInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetStreamsRecordedVideoFileIdMp4Response parses an HTTP response from a GetStreamsRecordedVideoFileIdMp4WithResponse call
func ParseGetStreamsRecordedVideoFileIdMp4Response(rsp *http.Response) (*GetStreamsRecordedVideoFileIdMp4Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStreamsRecordedVideoFileIdMp4Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetStreamsRecordedVideoFileIdWebmResponse parses an HTTP response from a GetStreamsRecordedVideoFileIdWebmWithResponse call
func ParseGetStreamsRecordedVideoFileIdWebmResponse(rsp *http.Response) (*GetStreamsRecordedVideoFileIdWebmResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStreamsRecordedVideoFileIdWebmResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteStreamsStreamIdResponse parses an HTTP response from a DeleteStreamsStreamIdWithResponse call
func ParseDeleteStreamsStreamIdResponse(rsp *http.Response) (*DeleteStreamsStreamIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteStreamsStreamIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePutStreamsStreamIdKeepResponse parses an HTTP response from a PutStreamsStreamIdKeepWithResponse call
func ParsePutStreamsStreamIdKeepResponse(rsp *http.Response) (*PutStreamsStreamIdKeepResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutStreamsStreamIdKeepResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetTagsResponse parses an HTTP response from a GetTagsWithResponse call
func ParseGetTagsResponse(rsp *http.Response) (*GetTagsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTagsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RecordedTags
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostTagsResponse parses an HTTP response from a PostTagsWithResponse call
func ParsePostTagsResponse(rsp *http.Response) (*PostTagsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostTagsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest AddedRecordedTag
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteTagsTagIdResponse parses an HTTP response from a DeleteTagsTagIdWithResponse call
func ParseDeleteTagsTagIdResponse(rsp *http.Response) (*DeleteTagsTagIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteTagsTagIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePutTagsTagIdResponse parses an HTTP response from a PutTagsTagIdWithResponse call
func ParsePutTagsTagIdResponse(rsp *http.Response) (*PutTagsTagIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutTagsTagIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteTagsTagIdRelateResponse parses an HTTP response from a DeleteTagsTagIdRelateWithResponse call
func ParseDeleteTagsTagIdRelateResponse(rsp *http.Response) (*DeleteTagsTagIdRelateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteTagsTagIdRelateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePutTagsTagIdRelateResponse parses an HTTP response from a PutTagsTagIdRelateWithResponse call
func ParsePutTagsTagIdRelateResponse(rsp *http.Response) (*PutTagsTagIdRelateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutTagsTagIdRelateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostThumbnailsResponse parses an HTTP response from a PostThumbnailsWithResponse call
func ParsePostThumbnailsResponse(rsp *http.Response) (*PostThumbnailsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostThumbnailsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostThumbnailsCleanupResponse parses an HTTP response from a PostThumbnailsCleanupWithResponse call
func ParsePostThumbnailsCleanupResponse(rsp *http.Response) (*PostThumbnailsCleanupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostThumbnailsCleanupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetThumbnailsThumbnailIdResponse parses an HTTP response from a GetThumbnailsThumbnailIdWithResponse call
func ParseGetThumbnailsThumbnailIdResponse(rsp *http.Response) (*GetThumbnailsThumbnailIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetThumbnailsThumbnailIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetVersionResponse parses an HTTP response from a GetVersionWithResponse call
func ParseGetVersionResponse(rsp *http.Response) (*GetVersionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVersionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Version
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostVideosUploadResponse parses an HTTP response from a PostVideosUploadWithResponse call
func ParsePostVideosUploadResponse(rsp *http.Response) (*PostVideosUploadResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostVideosUploadResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteVideosVideoFileIdResponse parses an HTTP response from a DeleteVideosVideoFileIdWithResponse call
func ParseDeleteVideosVideoFileIdResponse(rsp *http.Response) (*DeleteVideosVideoFileIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteVideosVideoFileIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetVideosVideoFileIdResponse parses an HTTP response from a GetVideosVideoFileIdWithResponse call
func ParseGetVideosVideoFileIdResponse(rsp *http.Response) (*GetVideosVideoFileIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVideosVideoFileIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetVideosVideoFileIdDurationResponse parses an HTTP response from a GetVideosVideoFileIdDurationWithResponse call
func ParseGetVideosVideoFileIdDurationResponse(rsp *http.Response) (*GetVideosVideoFileIdDurationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVideosVideoFileIdDurationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VideoFileDuration
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostVideosVideoFileIdKodiResponse parses an HTTP response from a PostVideosVideoFileIdKodiWithResponse call
func ParsePostVideosVideoFileIdKodiResponse(rsp *http.Response) (*PostVideosVideoFileIdKodiResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostVideosVideoFileIdKodiResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetVideosVideoFileIdPlaylistResponse parses an HTTP response from a GetVideosVideoFileIdPlaylistWithResponse call
func ParseGetVideosVideoFileIdPlaylistResponse(rsp *http.Response) (*GetVideosVideoFileIdPlaylistResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVideosVideoFileIdPlaylistResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// 放送局情報取得
	// (GET /channels)
	GetChannels(ctx echo.Context) error
	// 放送局ロゴ取得
	// (GET /channels/{channelId}/logo)
	GetChannelsChannelIdLogo(ctx echo.Context, channelId PathChannelId) error
	// config 情報取得
	// (GET /config)
	GetConfig(ctx echo.Context) error
	// ドロップログ
	// (GET /dropLogs/{dropLogFileId})
	GetDropLogsDropLogFileId(ctx echo.Context, dropLogFileId PathDropLogFileId, params GetDropLogsDropLogFileIdParams) error
	// エンコード情報取得
	// (GET /encode)
	GetEncode(ctx echo.Context, params GetEncodeParams) error
	// エンコード追加
	// (POST /encode)
	PostEncode(ctx echo.Context) error
	// エンコードをキャンセル
	// (DELETE /encode/{encodeId})
	DeleteEncodeEncodeId(ctx echo.Context, encodeId PathEncodeId) error
	// IPTV channel list を取得
	// (GET /iptv/channel.m3u8)
	GetIptvChannelM3u8(ctx echo.Context, params GetIptvChannelM3u8Params) error
	// IPTV epg を取得
	// (GET /iptv/epg.xml)
	GetIptvEpgXml(ctx echo.Context, params GetIptvEpgXmlParams) error
	// 録画情報取得
	// (GET /recorded)
	GetRecorded(ctx echo.Context, params GetRecordedParams) error
	// 録画番組情報の新規作成
	// (POST /recorded)
	PostRecorded(ctx echo.Context) error
	// 録画をクリーンアップ
	// (POST /recorded/cleanup)
	PostRecordedCleanup(ctx echo.Context) error
	// 録画検索オプションを取得
	// (GET /recorded/options)
	GetRecordedOptions(ctx echo.Context) error
	// 録画を削除
	// (DELETE /recorded/{recordedId})
	DeleteRecordedRecordedId(ctx echo.Context, recordedId PathRecordedId) error
	// 録画詳細情報を取得
	// (GET /recorded/{recordedId})
	GetRecordedRecordedId(ctx echo.Context, recordedId PathRecordedId, params GetRecordedRecordedIdParams) error
	// エンコード停止
	// (DELETE /recorded/{recordedId}/encode)
	DeleteRecordedRecordedIdEncode(ctx echo.Context, recordedId PathRecordedId) error
	// 録画を自動削除対象から除外
	// (PUT /recorded/{recordedId}/protect)
	PutRecordedRecordedIdProtect(ctx echo.Context, recordedId PathRecordedId) error
	// 録画を自動削除対象に戻す
	// (PUT /recorded/{recordedId}/unprotect)
	PutRecordedRecordedIdUnprotect(ctx echo.Context, recordedId PathRecordedId) error
	// 録画中情報取得
	// (GET /recording)
	GetRecording(ctx echo.Context, params GetRecordingParams) error
	// 予約タイマー再設定
	// (POST /recording/resettimer)
	PostRecordingResettimer(ctx echo.Context) error
	// 予約情報取得
	// (GET /reserves)
	GetReserves(ctx echo.Context, params GetReservesParams) error
	// 予約追加
	// (POST /reserves)
	PostReserves(ctx echo.Context) error
	// 予約数取得
	// (GET /reserves/cnts)
	GetReservesCnts(ctx echo.Context) error
	// 予約リスト情報取得
	// (GET /reserves/lists)
	GetReservesLists(ctx echo.Context, params GetReservesListsParams) error
	// 予約情報の更新開始
	// (POST /reserves/update)
	PostReservesUpdate(ctx echo.Context) error
	// 予約削除
	// (DELETE /reserves/{reserveId})
	DeleteReservesReserveId(ctx echo.Context, reserveId PathReserveId) error
	// 指定された予約情報の取得
	// (GET /reserves/{reserveId})
	GetReservesReserveId(ctx echo.Context, reserveId PathReserveId, params GetReservesReserveIdParams) error
	// 手動予約更新
	// (PUT /reserves/{reserveId})
	PutReservesReserveId(ctx echo.Context, reserveId PathReserveId) error
	// 予約の重複状態を解除
	// (DELETE /reserves/{reserveId}/overlap)
	DeleteReservesReserveIdOverlap(ctx echo.Context, reserveId PathReserveId) error
	// 予約の除外状態を解除
	// (DELETE /reserves/{reserveId}/skip)
	DeleteReservesReserveIdSkip(ctx echo.Context, reserveId PathReserveId) error
	// ルール情報取得
	// (GET /rules)
	GetRules(ctx echo.Context, params GetRulesParams) error
	// ルール追加
	// (POST /rules)
	PostRules(ctx echo.Context) error
	// ルールをキーワード検索
	// (GET /rules/keyword)
	GetRulesKeyword(ctx echo.Context, params GetRulesKeywordParams) error
	// ルール追加
	// (POST /rules/keyword)
	PostRulesKeyword(ctx echo.Context) error
	// ルール削除
	// (DELETE /rules/{ruleId})
	DeleteRulesRuleId(ctx echo.Context, ruleId PathRuleId) error
	// ルール取得
	// (GET /rules/{ruleId})
	GetRulesRuleId(ctx echo.Context, ruleId PathRuleId) error
	// ルール更新
	// (PUT /rules/{ruleId})
	PutRulesRuleId(ctx echo.Context, ruleId PathRuleId) error
	// ルール無効化
	// (PUT /rules/{ruleId}/disable)
	PutRulesRuleIdDisable(ctx echo.Context, ruleId PathRuleId) error
	// ルール有効化
	// (PUT /rules/{ruleId}/enable)
	PutRulesRuleIdEnable(ctx echo.Context, ruleId PathRuleId) error
	// 番組表情報取得
	// (GET /schedules)
	GetSchedules(ctx echo.Context, params GetSchedulesParams) error
	// 放映中の番組報取得
	// (GET /schedules/broadcasting)
	GetSchedulesBroadcasting(ctx echo.Context, params GetSchedulesBroadcastingParams) error
	// 指定された番組表情報取得
	// (GET /schedules/detail/{programId})
	GetSchedulesDetailProgramId(ctx echo.Context, programId PathProgramId, params GetSchedulesDetailProgramIdParams) error
	// 番組検索結果を取得
	// (POST /schedules/search)
	PostSchedulesSearch(ctx echo.Context) error
	// 指定された放送局の番組表情報取得
	// (GET /schedules/{channelId})
	GetSchedulesChannelId(ctx echo.Context, channelId PathChannelId, params GetSchedulesChannelIdParams) error
	// ストレージ情報取得
	// (GET /storages)
	GetStorages(ctx echo.Context) error
	// 全てのストリームを停止
	// (DELETE /streams)
	DeleteStreams(ctx echo.Context) error
	// ストリーム情報を取得
	// (GET /streams)
	GetStreams(ctx echo.Context, params GetStreamsParams) error
	// ライブ HLS ストリーム
	// (GET /streams/live/{channelId}/hls)
	GetStreamsLiveChannelIdHls(ctx echo.Context, channelId PathChannelId, params GetStreamsLiveChannelIdHlsParams) error
	// ライブ M2TS ストリーム
	// (GET /streams/live/{channelId}/m2ts)
	GetStreamsLiveChannelIdM2ts(ctx echo.Context, channelId PathChannelId, params GetStreamsLiveChannelIdM2tsParams) error
	// ライブ M2TS ストリームプレイリスト
	// (GET /streams/live/{channelId}/m2ts/playlist)
	GetStreamsLiveChannelIdM2tsPlaylist(ctx echo.Context, channelId PathChannelId, params GetStreamsLiveChannelIdM2tsPlaylistParams) error
	// ライブ M2TS Low Latency (mpegts.js 用) ストリーム
	// (GET /streams/live/{channelId}/m2tsll)
	GetStreamsLiveChannelIdM2tsll(ctx echo.Context, channelId PathChannelId, params GetStreamsLiveChannelIdM2tsllParams) error
	// ライブ mp4 ストリーム
	// (GET /streams/live/{channelId}/mp4)
	GetStreamsLiveChannelIdMp4(ctx echo.Context, channelId PathChannelId, params GetStreamsLiveChannelIdMp4Params) error
	// ライブ WebM ストリーム
	// (GET /streams/live/{channelId}/webm)
	GetStreamsLiveChannelIdWebm(ctx echo.Context, channelId PathChannelId, params GetStreamsLiveChannelIdWebmParams) error
	// 録画 HLS ストリーム
	// (GET /streams/recorded/{videoFileId}/hls)
	GetStreamsRecordedVideoFileIdHls(ctx echo.Context, videoFileId PathVideoFileId, params GetStreamsRecordedVideoFileIdHlsParams) error
	// 録画 mp4 ストリーム
	// (GET /streams/recorded/{videoFileId}/mp4)
	GetStreamsRecordedVideoFileIdMp4(ctx echo.Context, videoFileId PathVideoFileId, params GetStreamsRecordedVideoFileIdMp4Params) error
	// 録画 WebM ストリーム
	// (GET /streams/recorded/{videoFileId}/webm)
	GetStreamsRecordedVideoFileIdWebm(ctx echo.Context, videoFileId PathVideoFileId, params GetStreamsRecordedVideoFileIdWebmParams) error
	// ストリームを停止
	// (DELETE /streams/{streamId})
	DeleteStreamsStreamId(ctx echo.Context, streamId PathStreamId) error
	// ストリーム停止タイマーを更新する
	// (PUT /streams/{streamId}/keep)
	PutStreamsStreamIdKeep(ctx echo.Context, streamId PathStreamId) error
	// タグ情報取得
	// (GET /tags)
	GetTags(ctx echo.Context, params GetTagsParams) error
	// タグ追加
	// (POST /tags)
	PostTags(ctx echo.Context) error
	// タグ削除
	// (DELETE /tags/{tagId})
	DeleteTagsTagId(ctx echo.Context, tagId PathRecordedTagId) error
	// タグ名変更
	// (PUT /tags/{tagId})
	PutTagsTagId(ctx echo.Context, tagId PathRecordedTagId) error
	// 録画番組とタグの関連付けを削除
	// (DELETE /tags/{tagId}/relate)
	DeleteTagsTagIdRelate(ctx echo.Context, tagId PathRecordedTagId, params DeleteTagsTagIdRelateParams) error
	// 録画番組とタグを関連付ける
	// (PUT /tags/{tagId}/relate)
	PutTagsTagIdRelate(ctx echo.Context, tagId PathRecordedTagId) error
	// サムネイル再生成
	// (POST /thumbnails)
	PostThumbnails(ctx echo.Context) error
	// サムネイルをクリーンアップ
	// (POST /thumbnails/cleanup)
	PostThumbnailsCleanup(ctx echo.Context) error
	// サムネイル
	// (GET /thumbnails/{thumbnailId})
	GetThumbnailsThumbnailId(ctx echo.Context, thumbnailId PathThumbnailId) error
	// バージョン情報取得
	// (GET /version)
	GetVersion(ctx echo.Context) error
	// アップロードしたビデオファイルを追加
	// (POST /videos/upload)
	PostVideosUpload(ctx echo.Context) error
	// ビデオファイル
	// (DELETE /videos/{videoFileId})
	DeleteVideosVideoFileId(ctx echo.Context, videoFileId PathVideoFileId) error
	// ビデオファイル
	// (GET /videos/{videoFileId})
	GetVideosVideoFileId(ctx echo.Context, videoFileId PathVideoFileId, params GetVideosVideoFileIdParams) error
	// 動画の長さ
	// (GET /videos/{videoFileId}/duration)
	GetVideosVideoFileIdDuration(ctx echo.Context, videoFileId PathVideoFileId) error
	// ビデオリンクを kodi へ送信
	// (POST /videos/{videoFileId}/kodi)
	PostVideosVideoFileIdKodi(ctx echo.Context, videoFileId PathVideoFileId) error
	// ビデオプレイリスト
	// (GET /videos/{videoFileId}/playlist)
	GetVideosVideoFileIdPlaylist(ctx echo.Context, videoFileId PathVideoFileId) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// GetChannels converts echo context to params.
func (w *ServerInterfaceWrapper) GetChannels(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetChannels(ctx)
	return err
}

// GetChannelsChannelIdLogo converts echo context to params.
func (w *ServerInterfaceWrapper) GetChannelsChannelIdLogo(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "channelId" -------------
	var channelId PathChannelId

	err = runtime.BindStyledParameterWithLocation("simple", false, "channelId", runtime.ParamLocationPath, ctx.Param("channelId"), &channelId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter channelId: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetChannelsChannelIdLogo(ctx, channelId)
	return err
}

// GetConfig converts echo context to params.
func (w *ServerInterfaceWrapper) GetConfig(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetConfig(ctx)
	return err
}

// GetDropLogsDropLogFileId converts echo context to params.
func (w *ServerInterfaceWrapper) GetDropLogsDropLogFileId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "dropLogFileId" -------------
	var dropLogFileId PathDropLogFileId

	err = runtime.BindStyledParameterWithLocation("simple", false, "dropLogFileId", runtime.ParamLocationPath, ctx.Param("dropLogFileId"), &dropLogFileId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter dropLogFileId: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDropLogsDropLogFileIdParams
	// ------------- Optional query parameter "maxsize" -------------

	err = runtime.BindQueryParameter("form", true, false, "maxsize", ctx.QueryParams(), &params.Maxsize)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter maxsize: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetDropLogsDropLogFileId(ctx, dropLogFileId, params)
	return err
}

// GetEncode converts echo context to params.
func (w *ServerInterfaceWrapper) GetEncode(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetEncodeParams
	// ------------- Required query parameter "isHalfWidth" -------------

	err = runtime.BindQueryParameter("form", true, true, "isHalfWidth", ctx.QueryParams(), &params.IsHalfWidth)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter isHalfWidth: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetEncode(ctx, params)
	return err
}

// PostEncode converts echo context to params.
func (w *ServerInterfaceWrapper) PostEncode(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostEncode(ctx)
	return err
}

// DeleteEncodeEncodeId converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteEncodeEncodeId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "encodeId" -------------
	var encodeId PathEncodeId

	err = runtime.BindStyledParameterWithLocation("simple", false, "encodeId", runtime.ParamLocationPath, ctx.Param("encodeId"), &encodeId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter encodeId: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteEncodeEncodeId(ctx, encodeId)
	return err
}

// GetIptvChannelM3u8 converts echo context to params.
func (w *ServerInterfaceWrapper) GetIptvChannelM3u8(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetIptvChannelM3u8Params
	// ------------- Optional query parameter "isHalfWidth" -------------

	err = runtime.BindQueryParameter("form", true, false, "isHalfWidth", ctx.QueryParams(), &params.IsHalfWidth)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter isHalfWidth: %s", err))
	}

	// ------------- Required query parameter "mode" -------------

	err = runtime.BindQueryParameter("form", true, true, "mode", ctx.QueryParams(), &params.Mode)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter mode: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetIptvChannelM3u8(ctx, params)
	return err
}

// GetIptvEpgXml converts echo context to params.
func (w *ServerInterfaceWrapper) GetIptvEpgXml(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetIptvEpgXmlParams
	// ------------- Optional query parameter "isHalfWidth" -------------

	err = runtime.BindQueryParameter("form", true, false, "isHalfWidth", ctx.QueryParams(), &params.IsHalfWidth)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter isHalfWidth: %s", err))
	}

	// ------------- Optional query parameter "days" -------------

	err = runtime.BindQueryParameter("form", true, false, "days", ctx.QueryParams(), &params.Days)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter days: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetIptvEpgXml(ctx, params)
	return err
}

// GetRecorded converts echo context to params.
func (w *ServerInterfaceWrapper) GetRecorded(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetRecordedParams
	// ------------- Required query parameter "isHalfWidth" -------------

	err = runtime.BindQueryParameter("form", true, true, "isHalfWidth", ctx.QueryParams(), &params.IsHalfWidth)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter isHalfWidth: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "isReverse" -------------

	err = runtime.BindQueryParameter("form", true, false, "isReverse", ctx.QueryParams(), &params.IsReverse)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter isReverse: %s", err))
	}

	// ------------- Optional query parameter "ruleId" -------------

	err = runtime.BindQueryParameter("form", true, false, "ruleId", ctx.QueryParams(), &params.RuleId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ruleId: %s", err))
	}

	// ------------- Optional query parameter "channelId" -------------

	err = runtime.BindQueryParameter("form", true, false, "channelId", ctx.QueryParams(), &params.ChannelId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter channelId: %s", err))
	}

	// ------------- Optional query parameter "genre" -------------

	err = runtime.BindQueryParameter("form", true, false, "genre", ctx.QueryParams(), &params.Genre)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter genre: %s", err))
	}

	// ------------- Optional query parameter "keyword" -------------

	err = runtime.BindQueryParameter("form", true, false, "keyword", ctx.QueryParams(), &params.Keyword)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter keyword: %s", err))
	}

	// ------------- Optional query parameter "hasOriginalFile" -------------

	err = runtime.BindQueryParameter("form", true, false, "hasOriginalFile", ctx.QueryParams(), &params.HasOriginalFile)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hasOriginalFile: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetRecorded(ctx, params)
	return err
}

// PostRecorded converts echo context to params.
func (w *ServerInterfaceWrapper) PostRecorded(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostRecorded(ctx)
	return err
}

// PostRecordedCleanup converts echo context to params.
func (w *ServerInterfaceWrapper) PostRecordedCleanup(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostRecordedCleanup(ctx)
	return err
}

// GetRecordedOptions converts echo context to params.
func (w *ServerInterfaceWrapper) GetRecordedOptions(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetRecordedOptions(ctx)
	return err
}

// DeleteRecordedRecordedId converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteRecordedRecordedId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "recordedId" -------------
	var recordedId PathRecordedId

	err = runtime.BindStyledParameterWithLocation("simple", false, "recordedId", runtime.ParamLocationPath, ctx.Param("recordedId"), &recordedId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter recordedId: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteRecordedRecordedId(ctx, recordedId)
	return err
}

// GetRecordedRecordedId converts echo context to params.
func (w *ServerInterfaceWrapper) GetRecordedRecordedId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "recordedId" -------------
	var recordedId PathRecordedId

	err = runtime.BindStyledParameterWithLocation("simple", false, "recordedId", runtime.ParamLocationPath, ctx.Param("recordedId"), &recordedId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter recordedId: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetRecordedRecordedIdParams
	// ------------- Required query parameter "isHalfWidth" -------------

	err = runtime.BindQueryParameter("form", true, true, "isHalfWidth", ctx.QueryParams(), &params.IsHalfWidth)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter isHalfWidth: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetRecordedRecordedId(ctx, recordedId, params)
	return err
}

// DeleteRecordedRecordedIdEncode converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteRecordedRecordedIdEncode(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "recordedId" -------------
	var recordedId PathRecordedId

	err = runtime.BindStyledParameterWithLocation("simple", false, "recordedId", runtime.ParamLocationPath, ctx.Param("recordedId"), &recordedId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter recordedId: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteRecordedRecordedIdEncode(ctx, recordedId)
	return err
}

// PutRecordedRecordedIdProtect converts echo context to params.
func (w *ServerInterfaceWrapper) PutRecordedRecordedIdProtect(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "recordedId" -------------
	var recordedId PathRecordedId

	err = runtime.BindStyledParameterWithLocation("simple", false, "recordedId", runtime.ParamLocationPath, ctx.Param("recordedId"), &recordedId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter recordedId: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PutRecordedRecordedIdProtect(ctx, recordedId)
	return err
}

// PutRecordedRecordedIdUnprotect converts echo context to params.
func (w *ServerInterfaceWrapper) PutRecordedRecordedIdUnprotect(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "recordedId" -------------
	var recordedId PathRecordedId

	err = runtime.BindStyledParameterWithLocation("simple", false, "recordedId", runtime.ParamLocationPath, ctx.Param("recordedId"), &recordedId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter recordedId: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PutRecordedRecordedIdUnprotect(ctx, recordedId)
	return err
}

// GetRecording converts echo context to params.
func (w *ServerInterfaceWrapper) GetRecording(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetRecordingParams
	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Required query parameter "isHalfWidth" -------------

	err = runtime.BindQueryParameter("form", true, true, "isHalfWidth", ctx.QueryParams(), &params.IsHalfWidth)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter isHalfWidth: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetRecording(ctx, params)
	return err
}

// PostRecordingResettimer converts echo context to params.
func (w *ServerInterfaceWrapper) PostRecordingResettimer(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostRecordingResettimer(ctx)
	return err
}

// GetReserves converts echo context to params.
func (w *ServerInterfaceWrapper) GetReserves(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetReservesParams
	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Required query parameter "isHalfWidth" -------------

	err = runtime.BindQueryParameter("form", true, true, "isHalfWidth", ctx.QueryParams(), &params.IsHalfWidth)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter isHalfWidth: %s", err))
	}

	// ------------- Optional query parameter "ruleId" -------------

	err = runtime.BindQueryParameter("form", true, false, "ruleId", ctx.QueryParams(), &params.RuleId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ruleId: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetReserves(ctx, params)
	return err
}

// PostReserves converts echo context to params.
func (w *ServerInterfaceWrapper) PostReserves(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostReserves(ctx)
	return err
}

// GetReservesCnts converts echo context to params.
func (w *ServerInterfaceWrapper) GetReservesCnts(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetReservesCnts(ctx)
	return err
}

// GetReservesLists converts echo context to params.
func (w *ServerInterfaceWrapper) GetReservesLists(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetReservesListsParams
	// ------------- Required query parameter "startAt" -------------

	err = runtime.BindQueryParameter("form", true, true, "startAt", ctx.QueryParams(), &params.StartAt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter startAt: %s", err))
	}

	// ------------- Required query parameter "endAt" -------------

	err = runtime.BindQueryParameter("form", true, true, "endAt", ctx.QueryParams(), &params.EndAt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter endAt: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetReservesLists(ctx, params)
	return err
}

// PostReservesUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) PostReservesUpdate(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostReservesUpdate(ctx)
	return err
}

// DeleteReservesReserveId converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteReservesReserveId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "reserveId" -------------
	var reserveId PathReserveId

	err = runtime.BindStyledParameterWithLocation("simple", false, "reserveId", runtime.ParamLocationPath, ctx.Param("reserveId"), &reserveId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter reserveId: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteReservesReserveId(ctx, reserveId)
	return err
}

// GetReservesReserveId converts echo context to params.
func (w *ServerInterfaceWrapper) GetReservesReserveId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "reserveId" -------------
	var reserveId PathReserveId

	err = runtime.BindStyledParameterWithLocation("simple", false, "reserveId", runtime.ParamLocationPath, ctx.Param("reserveId"), &reserveId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter reserveId: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetReservesReserveIdParams
	// ------------- Required query parameter "isHalfWidth" -------------

	err = runtime.BindQueryParameter("form", true, true, "isHalfWidth", ctx.QueryParams(), &params.IsHalfWidth)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter isHalfWidth: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetReservesReserveId(ctx, reserveId, params)
	return err
}

// PutReservesReserveId converts echo context to params.
func (w *ServerInterfaceWrapper) PutReservesReserveId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "reserveId" -------------
	var reserveId PathReserveId

	err = runtime.BindStyledParameterWithLocation("simple", false, "reserveId", runtime.ParamLocationPath, ctx.Param("reserveId"), &reserveId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter reserveId: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PutReservesReserveId(ctx, reserveId)
	return err
}

// DeleteReservesReserveIdOverlap converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteReservesReserveIdOverlap(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "reserveId" -------------
	var reserveId PathReserveId

	err = runtime.BindStyledParameterWithLocation("simple", false, "reserveId", runtime.ParamLocationPath, ctx.Param("reserveId"), &reserveId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter reserveId: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteReservesReserveIdOverlap(ctx, reserveId)
	return err
}

// DeleteReservesReserveIdSkip converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteReservesReserveIdSkip(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "reserveId" -------------
	var reserveId PathReserveId

	err = runtime.BindStyledParameterWithLocation("simple", false, "reserveId", runtime.ParamLocationPath, ctx.Param("reserveId"), &reserveId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter reserveId: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteReservesReserveIdSkip(ctx, reserveId)
	return err
}

// GetRules converts echo context to params.
func (w *ServerInterfaceWrapper) GetRules(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetRulesParams
	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "keyword" -------------

	err = runtime.BindQueryParameter("form", true, false, "keyword", ctx.QueryParams(), &params.Keyword)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter keyword: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetRules(ctx, params)
	return err
}

// PostRules converts echo context to params.
func (w *ServerInterfaceWrapper) PostRules(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostRules(ctx)
	return err
}

// GetRulesKeyword converts echo context to params.
func (w *ServerInterfaceWrapper) GetRulesKeyword(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetRulesKeywordParams
	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "keyword" -------------

	err = runtime.BindQueryParameter("form", true, false, "keyword", ctx.QueryParams(), &params.Keyword)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter keyword: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetRulesKeyword(ctx, params)
	return err
}

// PostRulesKeyword converts echo context to params.
func (w *ServerInterfaceWrapper) PostRulesKeyword(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostRulesKeyword(ctx)
	return err
}

// DeleteRulesRuleId converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteRulesRuleId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ruleId" -------------
	var ruleId PathRuleId

	err = runtime.BindStyledParameterWithLocation("simple", false, "ruleId", runtime.ParamLocationPath, ctx.Param("ruleId"), &ruleId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ruleId: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteRulesRuleId(ctx, ruleId)
	return err
}

// GetRulesRuleId converts echo context to params.
func (w *ServerInterfaceWrapper) GetRulesRuleId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ruleId" -------------
	var ruleId PathRuleId

	err = runtime.BindStyledParameterWithLocation("simple", false, "ruleId", runtime.ParamLocationPath, ctx.Param("ruleId"), &ruleId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ruleId: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetRulesRuleId(ctx, ruleId)
	return err
}

// PutRulesRuleId converts echo context to params.
func (w *ServerInterfaceWrapper) PutRulesRuleId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ruleId" -------------
	var ruleId PathRuleId

	err = runtime.BindStyledParameterWithLocation("simple", false, "ruleId", runtime.ParamLocationPath, ctx.Param("ruleId"), &ruleId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ruleId: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PutRulesRuleId(ctx, ruleId)
	return err
}

// PutRulesRuleIdDisable converts echo context to params.
func (w *ServerInterfaceWrapper) PutRulesRuleIdDisable(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ruleId" -------------
	var ruleId PathRuleId

	err = runtime.BindStyledParameterWithLocation("simple", false, "ruleId", runtime.ParamLocationPath, ctx.Param("ruleId"), &ruleId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ruleId: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PutRulesRuleIdDisable(ctx, ruleId)
	return err
}

// PutRulesRuleIdEnable converts echo context to params.
func (w *ServerInterfaceWrapper) PutRulesRuleIdEnable(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ruleId" -------------
	var ruleId PathRuleId

	err = runtime.BindStyledParameterWithLocation("simple", false, "ruleId", runtime.ParamLocationPath, ctx.Param("ruleId"), &ruleId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ruleId: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PutRulesRuleIdEnable(ctx, ruleId)
	return err
}

// GetSchedules converts echo context to params.
func (w *ServerInterfaceWrapper) GetSchedules(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetSchedulesParams
	// ------------- Required query parameter "startAt" -------------

	err = runtime.BindQueryParameter("form", true, true, "startAt", ctx.QueryParams(), &params.StartAt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter startAt: %s", err))
	}

	// ------------- Required query parameter "endAt" -------------

	err = runtime.BindQueryParameter("form", true, true, "endAt", ctx.QueryParams(), &params.EndAt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter endAt: %s", err))
	}

	// ------------- Required query parameter "isHalfWidth" -------------

	err = runtime.BindQueryParameter("form", true, true, "isHalfWidth", ctx.QueryParams(), &params.IsHalfWidth)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter isHalfWidth: %s", err))
	}

	// ------------- Optional query parameter "needsRawExtended" -------------

	err = runtime.BindQueryParameter("form", true, false, "needsRawExtended", ctx.QueryParams(), &params.NeedsRawExtended)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter needsRawExtended: %s", err))
	}

	// ------------- Optional query parameter "isFree" -------------

	err = runtime.BindQueryParameter("form", true, false, "isFree", ctx.QueryParams(), &params.IsFree)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter isFree: %s", err))
	}

	// ------------- Required query parameter "GR" -------------

	err = runtime.BindQueryParameter("form", true, true, "GR", ctx.QueryParams(), &params.GR)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter GR: %s", err))
	}

	// ------------- Required query parameter "BS" -------------

	err = runtime.BindQueryParameter("form", true, true, "BS", ctx.QueryParams(), &params.BS)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter BS: %s", err))
	}

	// ------------- Required query parameter "CS" -------------

	err = runtime.BindQueryParameter("form", true, true, "CS", ctx.QueryParams(), &params.CS)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter CS: %s", err))
	}

	// ------------- Required query parameter "SKY" -------------

	err = runtime.BindQueryParameter("form", true, true, "SKY", ctx.QueryParams(), &params.SKY)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter SKY: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSchedules(ctx, params)
	return err
}

// GetSchedulesBroadcasting converts echo context to params.
func (w *ServerInterfaceWrapper) GetSchedulesBroadcasting(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetSchedulesBroadcastingParams
	// ------------- Optional query parameter "time" -------------

	err = runtime.BindQueryParameter("form", true, false, "time", ctx.QueryParams(), &params.Time)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter time: %s", err))
	}

	// ------------- Required query parameter "isHalfWidth" -------------

	err = runtime.BindQueryParameter("form", true, true, "isHalfWidth", ctx.QueryParams(), &params.IsHalfWidth)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter isHalfWidth: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSchedulesBroadcasting(ctx, params)
	return err
}

// GetSchedulesDetailProgramId converts echo context to params.
func (w *ServerInterfaceWrapper) GetSchedulesDetailProgramId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "programId" -------------
	var programId PathProgramId

	err = runtime.BindStyledParameterWithLocation("simple", false, "programId", runtime.ParamLocationPath, ctx.Param("programId"), &programId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter programId: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetSchedulesDetailProgramIdParams
	// ------------- Required query parameter "isHalfWidth" -------------

	err = runtime.BindQueryParameter("form", true, true, "isHalfWidth", ctx.QueryParams(), &params.IsHalfWidth)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter isHalfWidth: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSchedulesDetailProgramId(ctx, programId, params)
	return err
}

// PostSchedulesSearch converts echo context to params.
func (w *ServerInterfaceWrapper) PostSchedulesSearch(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostSchedulesSearch(ctx)
	return err
}

// GetSchedulesChannelId converts echo context to params.
func (w *ServerInterfaceWrapper) GetSchedulesChannelId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "channelId" -------------
	var channelId PathChannelId

	err = runtime.BindStyledParameterWithLocation("simple", false, "channelId", runtime.ParamLocationPath, ctx.Param("channelId"), &channelId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter channelId: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetSchedulesChannelIdParams
	// ------------- Required query parameter "startAt" -------------

	err = runtime.BindQueryParameter("form", true, true, "startAt", ctx.QueryParams(), &params.StartAt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter startAt: %s", err))
	}

	// ------------- Required query parameter "days" -------------

	err = runtime.BindQueryParameter("form", true, true, "days", ctx.QueryParams(), &params.Days)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter days: %s", err))
	}

	// ------------- Required query parameter "isHalfWidth" -------------

	err = runtime.BindQueryParameter("form", true, true, "isHalfWidth", ctx.QueryParams(), &params.IsHalfWidth)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter isHalfWidth: %s", err))
	}

	// ------------- Optional query parameter "needsRawExtended" -------------

	err = runtime.BindQueryParameter("form", true, false, "needsRawExtended", ctx.QueryParams(), &params.NeedsRawExtended)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter needsRawExtended: %s", err))
	}

	// ------------- Optional query parameter "isFree" -------------

	err = runtime.BindQueryParameter("form", true, false, "isFree", ctx.QueryParams(), &params.IsFree)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter isFree: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSchedulesChannelId(ctx, channelId, params)
	return err
}

// GetStorages converts echo context to params.
func (w *ServerInterfaceWrapper) GetStorages(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetStorages(ctx)
	return err
}

// DeleteStreams converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteStreams(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteStreams(ctx)
	return err
}

// GetStreams converts echo context to params.
func (w *ServerInterfaceWrapper) GetStreams(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetStreamsParams
	// ------------- Required query parameter "isHalfWidth" -------------

	err = runtime.BindQueryParameter("form", true, true, "isHalfWidth", ctx.QueryParams(), &params.IsHalfWidth)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter isHalfWidth: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetStreams(ctx, params)
	return err
}

// GetStreamsLiveChannelIdHls converts echo context to params.
func (w *ServerInterfaceWrapper) GetStreamsLiveChannelIdHls(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "channelId" -------------
	var channelId PathChannelId

	err = runtime.BindStyledParameterWithLocation("simple", false, "channelId", runtime.ParamLocationPath, ctx.Param("channelId"), &channelId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter channelId: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetStreamsLiveChannelIdHlsParams
	// ------------- Required query parameter "mode" -------------

	err = runtime.BindQueryParameter("form", true, true, "mode", ctx.QueryParams(), &params.Mode)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter mode: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetStreamsLiveChannelIdHls(ctx, channelId, params)
	return err
}

// GetStreamsLiveChannelIdM2ts converts echo context to params.
func (w *ServerInterfaceWrapper) GetStreamsLiveChannelIdM2ts(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "channelId" -------------
	var channelId PathChannelId

	err = runtime.BindStyledParameterWithLocation("simple", false, "channelId", runtime.ParamLocationPath, ctx.Param("channelId"), &channelId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter channelId: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetStreamsLiveChannelIdM2tsParams
	// ------------- Required query parameter "mode" -------------

	err = runtime.BindQueryParameter("form", true, true, "mode", ctx.QueryParams(), &params.Mode)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter mode: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetStreamsLiveChannelIdM2ts(ctx, channelId, params)
	return err
}

// GetStreamsLiveChannelIdM2tsPlaylist converts echo context to params.
func (w *ServerInterfaceWrapper) GetStreamsLiveChannelIdM2tsPlaylist(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "channelId" -------------
	var channelId PathChannelId

	err = runtime.BindStyledParameterWithLocation("simple", false, "channelId", runtime.ParamLocationPath, ctx.Param("channelId"), &channelId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter channelId: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetStreamsLiveChannelIdM2tsPlaylistParams
	// ------------- Required query parameter "mode" -------------

	err = runtime.BindQueryParameter("form", true, true, "mode", ctx.QueryParams(), &params.Mode)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter mode: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetStreamsLiveChannelIdM2tsPlaylist(ctx, channelId, params)
	return err
}

// GetStreamsLiveChannelIdM2tsll converts echo context to params.
func (w *ServerInterfaceWrapper) GetStreamsLiveChannelIdM2tsll(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "channelId" -------------
	var channelId PathChannelId

	err = runtime.BindStyledParameterWithLocation("simple", false, "channelId", runtime.ParamLocationPath, ctx.Param("channelId"), &channelId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter channelId: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetStreamsLiveChannelIdM2tsllParams
	// ------------- Required query parameter "mode" -------------

	err = runtime.BindQueryParameter("form", true, true, "mode", ctx.QueryParams(), &params.Mode)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter mode: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetStreamsLiveChannelIdM2tsll(ctx, channelId, params)
	return err
}

// GetStreamsLiveChannelIdMp4 converts echo context to params.
func (w *ServerInterfaceWrapper) GetStreamsLiveChannelIdMp4(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "channelId" -------------
	var channelId PathChannelId

	err = runtime.BindStyledParameterWithLocation("simple", false, "channelId", runtime.ParamLocationPath, ctx.Param("channelId"), &channelId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter channelId: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetStreamsLiveChannelIdMp4Params
	// ------------- Required query parameter "mode" -------------

	err = runtime.BindQueryParameter("form", true, true, "mode", ctx.QueryParams(), &params.Mode)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter mode: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetStreamsLiveChannelIdMp4(ctx, channelId, params)
	return err
}

// GetStreamsLiveChannelIdWebm converts echo context to params.
func (w *ServerInterfaceWrapper) GetStreamsLiveChannelIdWebm(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "channelId" -------------
	var channelId PathChannelId

	err = runtime.BindStyledParameterWithLocation("simple", false, "channelId", runtime.ParamLocationPath, ctx.Param("channelId"), &channelId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter channelId: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetStreamsLiveChannelIdWebmParams
	// ------------- Required query parameter "mode" -------------

	err = runtime.BindQueryParameter("form", true, true, "mode", ctx.QueryParams(), &params.Mode)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter mode: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetStreamsLiveChannelIdWebm(ctx, channelId, params)
	return err
}

// GetStreamsRecordedVideoFileIdHls converts echo context to params.
func (w *ServerInterfaceWrapper) GetStreamsRecordedVideoFileIdHls(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "videoFileId" -------------
	var videoFileId PathVideoFileId

	err = runtime.BindStyledParameterWithLocation("simple", false, "videoFileId", runtime.ParamLocationPath, ctx.Param("videoFileId"), &videoFileId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter videoFileId: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetStreamsRecordedVideoFileIdHlsParams
	// ------------- Required query parameter "ss" -------------

	err = runtime.BindQueryParameter("form", true, true, "ss", ctx.QueryParams(), &params.Ss)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ss: %s", err))
	}

	// ------------- Required query parameter "mode" -------------

	err = runtime.BindQueryParameter("form", true, true, "mode", ctx.QueryParams(), &params.Mode)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter mode: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetStreamsRecordedVideoFileIdHls(ctx, videoFileId, params)
	return err
}

// GetStreamsRecordedVideoFileIdMp4 converts echo context to params.
func (w *ServerInterfaceWrapper) GetStreamsRecordedVideoFileIdMp4(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "videoFileId" -------------
	var videoFileId PathVideoFileId

	err = runtime.BindStyledParameterWithLocation("simple", false, "videoFileId", runtime.ParamLocationPath, ctx.Param("videoFileId"), &videoFileId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter videoFileId: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetStreamsRecordedVideoFileIdMp4Params
	// ------------- Required query parameter "ss" -------------

	err = runtime.BindQueryParameter("form", true, true, "ss", ctx.QueryParams(), &params.Ss)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ss: %s", err))
	}

	// ------------- Required query parameter "mode" -------------

	err = runtime.BindQueryParameter("form", true, true, "mode", ctx.QueryParams(), &params.Mode)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter mode: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetStreamsRecordedVideoFileIdMp4(ctx, videoFileId, params)
	return err
}

// GetStreamsRecordedVideoFileIdWebm converts echo context to params.
func (w *ServerInterfaceWrapper) GetStreamsRecordedVideoFileIdWebm(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "videoFileId" -------------
	var videoFileId PathVideoFileId

	err = runtime.BindStyledParameterWithLocation("simple", false, "videoFileId", runtime.ParamLocationPath, ctx.Param("videoFileId"), &videoFileId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter videoFileId: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetStreamsRecordedVideoFileIdWebmParams
	// ------------- Required query parameter "ss" -------------

	err = runtime.BindQueryParameter("form", true, true, "ss", ctx.QueryParams(), &params.Ss)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ss: %s", err))
	}

	// ------------- Required query parameter "mode" -------------

	err = runtime.BindQueryParameter("form", true, true, "mode", ctx.QueryParams(), &params.Mode)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter mode: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetStreamsRecordedVideoFileIdWebm(ctx, videoFileId, params)
	return err
}

// DeleteStreamsStreamId converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteStreamsStreamId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "streamId" -------------
	var streamId PathStreamId

	err = runtime.BindStyledParameterWithLocation("simple", false, "streamId", runtime.ParamLocationPath, ctx.Param("streamId"), &streamId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter streamId: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteStreamsStreamId(ctx, streamId)
	return err
}

// PutStreamsStreamIdKeep converts echo context to params.
func (w *ServerInterfaceWrapper) PutStreamsStreamIdKeep(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "streamId" -------------
	var streamId PathStreamId

	err = runtime.BindStyledParameterWithLocation("simple", false, "streamId", runtime.ParamLocationPath, ctx.Param("streamId"), &streamId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter streamId: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PutStreamsStreamIdKeep(ctx, streamId)
	return err
}

// GetTags converts echo context to params.
func (w *ServerInterfaceWrapper) GetTags(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTagsParams
	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "excludeTagId" -------------

	err = runtime.BindQueryParameter("form", true, false, "excludeTagId", ctx.QueryParams(), &params.ExcludeTagId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter excludeTagId: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetTags(ctx, params)
	return err
}

// PostTags converts echo context to params.
func (w *ServerInterfaceWrapper) PostTags(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostTags(ctx)
	return err
}

// DeleteTagsTagId converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteTagsTagId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "tagId" -------------
	var tagId PathRecordedTagId

	err = runtime.BindStyledParameterWithLocation("simple", false, "tagId", runtime.ParamLocationPath, ctx.Param("tagId"), &tagId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tagId: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteTagsTagId(ctx, tagId)
	return err
}

// PutTagsTagId converts echo context to params.
func (w *ServerInterfaceWrapper) PutTagsTagId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "tagId" -------------
	var tagId PathRecordedTagId

	err = runtime.BindStyledParameterWithLocation("simple", false, "tagId", runtime.ParamLocationPath, ctx.Param("tagId"), &tagId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tagId: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PutTagsTagId(ctx, tagId)
	return err
}

// DeleteTagsTagIdRelate converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteTagsTagIdRelate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "tagId" -------------
	var tagId PathRecordedTagId

	err = runtime.BindStyledParameterWithLocation("simple", false, "tagId", runtime.ParamLocationPath, ctx.Param("tagId"), &tagId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tagId: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteTagsTagIdRelateParams
	// ------------- Optional query parameter "recordedId" -------------

	err = runtime.BindQueryParameter("form", true, false, "recordedId", ctx.QueryParams(), &params.RecordedId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter recordedId: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteTagsTagIdRelate(ctx, tagId, params)
	return err
}

// PutTagsTagIdRelate converts echo context to params.
func (w *ServerInterfaceWrapper) PutTagsTagIdRelate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "tagId" -------------
	var tagId PathRecordedTagId

	err = runtime.BindStyledParameterWithLocation("simple", false, "tagId", runtime.ParamLocationPath, ctx.Param("tagId"), &tagId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tagId: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PutTagsTagIdRelate(ctx, tagId)
	return err
}

// PostThumbnails converts echo context to params.
func (w *ServerInterfaceWrapper) PostThumbnails(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostThumbnails(ctx)
	return err
}

// PostThumbnailsCleanup converts echo context to params.
func (w *ServerInterfaceWrapper) PostThumbnailsCleanup(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostThumbnailsCleanup(ctx)
	return err
}

// GetThumbnailsThumbnailId converts echo context to params.
func (w *ServerInterfaceWrapper) GetThumbnailsThumbnailId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "thumbnailId" -------------
	var thumbnailId PathThumbnailId

	err = runtime.BindStyledParameterWithLocation("simple", false, "thumbnailId", runtime.ParamLocationPath, ctx.Param("thumbnailId"), &thumbnailId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter thumbnailId: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetThumbnailsThumbnailId(ctx, thumbnailId)
	return err
}

// GetVersion converts echo context to params.
func (w *ServerInterfaceWrapper) GetVersion(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetVersion(ctx)
	return err
}

// PostVideosUpload converts echo context to params.
func (w *ServerInterfaceWrapper) PostVideosUpload(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostVideosUpload(ctx)
	return err
}

// DeleteVideosVideoFileId converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteVideosVideoFileId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "videoFileId" -------------
	var videoFileId PathVideoFileId

	err = runtime.BindStyledParameterWithLocation("simple", false, "videoFileId", runtime.ParamLocationPath, ctx.Param("videoFileId"), &videoFileId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter videoFileId: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteVideosVideoFileId(ctx, videoFileId)
	return err
}

// GetVideosVideoFileId converts echo context to params.
func (w *ServerInterfaceWrapper) GetVideosVideoFileId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "videoFileId" -------------
	var videoFileId PathVideoFileId

	err = runtime.BindStyledParameterWithLocation("simple", false, "videoFileId", runtime.ParamLocationPath, ctx.Param("videoFileId"), &videoFileId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter videoFileId: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetVideosVideoFileIdParams
	// ------------- Optional query parameter "isDownload" -------------

	err = runtime.BindQueryParameter("form", true, false, "isDownload", ctx.QueryParams(), &params.IsDownload)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter isDownload: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetVideosVideoFileId(ctx, videoFileId, params)
	return err
}

// GetVideosVideoFileIdDuration converts echo context to params.
func (w *ServerInterfaceWrapper) GetVideosVideoFileIdDuration(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "videoFileId" -------------
	var videoFileId PathVideoFileId

	err = runtime.BindStyledParameterWithLocation("simple", false, "videoFileId", runtime.ParamLocationPath, ctx.Param("videoFileId"), &videoFileId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter videoFileId: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetVideosVideoFileIdDuration(ctx, videoFileId)
	return err
}

// PostVideosVideoFileIdKodi converts echo context to params.
func (w *ServerInterfaceWrapper) PostVideosVideoFileIdKodi(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "videoFileId" -------------
	var videoFileId PathVideoFileId

	err = runtime.BindStyledParameterWithLocation("simple", false, "videoFileId", runtime.ParamLocationPath, ctx.Param("videoFileId"), &videoFileId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter videoFileId: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostVideosVideoFileIdKodi(ctx, videoFileId)
	return err
}

// GetVideosVideoFileIdPlaylist converts echo context to params.
func (w *ServerInterfaceWrapper) GetVideosVideoFileIdPlaylist(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "videoFileId" -------------
	var videoFileId PathVideoFileId

	err = runtime.BindStyledParameterWithLocation("simple", false, "videoFileId", runtime.ParamLocationPath, ctx.Param("videoFileId"), &videoFileId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter videoFileId: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetVideosVideoFileIdPlaylist(ctx, videoFileId)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/channels", wrapper.GetChannels)
	router.GET(baseURL+"/channels/:channelId/logo", wrapper.GetChannelsChannelIdLogo)
	router.GET(baseURL+"/config", wrapper.GetConfig)
	router.GET(baseURL+"/dropLogs/:dropLogFileId", wrapper.GetDropLogsDropLogFileId)
	router.GET(baseURL+"/encode", wrapper.GetEncode)
	router.POST(baseURL+"/encode", wrapper.PostEncode)
	router.DELETE(baseURL+"/encode/:encodeId", wrapper.DeleteEncodeEncodeId)
	router.GET(baseURL+"/iptv/channel.m3u8", wrapper.GetIptvChannelM3u8)
	router.GET(baseURL+"/iptv/epg.xml", wrapper.GetIptvEpgXml)
	router.GET(baseURL+"/recorded", wrapper.GetRecorded)
	router.POST(baseURL+"/recorded", wrapper.PostRecorded)
	router.POST(baseURL+"/recorded/cleanup", wrapper.PostRecordedCleanup)
	router.GET(baseURL+"/recorded/options", wrapper.GetRecordedOptions)
	router.DELETE(baseURL+"/recorded/:recordedId", wrapper.DeleteRecordedRecordedId)
	router.GET(baseURL+"/recorded/:recordedId", wrapper.GetRecordedRecordedId)
	router.DELETE(baseURL+"/recorded/:recordedId/encode", wrapper.DeleteRecordedRecordedIdEncode)
	router.PUT(baseURL+"/recorded/:recordedId/protect", wrapper.PutRecordedRecordedIdProtect)
	router.PUT(baseURL+"/recorded/:recordedId/unprotect", wrapper.PutRecordedRecordedIdUnprotect)
	router.GET(baseURL+"/recording", wrapper.GetRecording)
	router.POST(baseURL+"/recording/resettimer", wrapper.PostRecordingResettimer)
	router.GET(baseURL+"/reserves", wrapper.GetReserves)
	router.POST(baseURL+"/reserves", wrapper.PostReserves)
	router.GET(baseURL+"/reserves/cnts", wrapper.GetReservesCnts)
	router.GET(baseURL+"/reserves/lists", wrapper.GetReservesLists)
	router.POST(baseURL+"/reserves/update", wrapper.PostReservesUpdate)
	router.DELETE(baseURL+"/reserves/:reserveId", wrapper.DeleteReservesReserveId)
	router.GET(baseURL+"/reserves/:reserveId", wrapper.GetReservesReserveId)
	router.PUT(baseURL+"/reserves/:reserveId", wrapper.PutReservesReserveId)
	router.DELETE(baseURL+"/reserves/:reserveId/overlap", wrapper.DeleteReservesReserveIdOverlap)
	router.DELETE(baseURL+"/reserves/:reserveId/skip", wrapper.DeleteReservesReserveIdSkip)
	router.GET(baseURL+"/rules", wrapper.GetRules)
	router.POST(baseURL+"/rules", wrapper.PostRules)
	router.GET(baseURL+"/rules/keyword", wrapper.GetRulesKeyword)
	router.POST(baseURL+"/rules/keyword", wrapper.PostRulesKeyword)
	router.DELETE(baseURL+"/rules/:ruleId", wrapper.DeleteRulesRuleId)
	router.GET(baseURL+"/rules/:ruleId", wrapper.GetRulesRuleId)
	router.PUT(baseURL+"/rules/:ruleId", wrapper.PutRulesRuleId)
	router.PUT(baseURL+"/rules/:ruleId/disable", wrapper.PutRulesRuleIdDisable)
	router.PUT(baseURL+"/rules/:ruleId/enable", wrapper.PutRulesRuleIdEnable)
	router.GET(baseURL+"/schedules", wrapper.GetSchedules)
	router.GET(baseURL+"/schedules/broadcasting", wrapper.GetSchedulesBroadcasting)
	router.GET(baseURL+"/schedules/detail/:programId", wrapper.GetSchedulesDetailProgramId)
	router.POST(baseURL+"/schedules/search", wrapper.PostSchedulesSearch)
	router.GET(baseURL+"/schedules/:channelId", wrapper.GetSchedulesChannelId)
	router.GET(baseURL+"/storages", wrapper.GetStorages)
	router.DELETE(baseURL+"/streams", wrapper.DeleteStreams)
	router.GET(baseURL+"/streams", wrapper.GetStreams)
	router.GET(baseURL+"/streams/live/:channelId/hls", wrapper.GetStreamsLiveChannelIdHls)
	router.GET(baseURL+"/streams/live/:channelId/m2ts", wrapper.GetStreamsLiveChannelIdM2ts)
	router.GET(baseURL+"/streams/live/:channelId/m2ts/playlist", wrapper.GetStreamsLiveChannelIdM2tsPlaylist)
	router.GET(baseURL+"/streams/live/:channelId/m2tsll", wrapper.GetStreamsLiveChannelIdM2tsll)
	router.GET(baseURL+"/streams/live/:channelId/mp4", wrapper.GetStreamsLiveChannelIdMp4)
	router.GET(baseURL+"/streams/live/:channelId/webm", wrapper.GetStreamsLiveChannelIdWebm)
	router.GET(baseURL+"/streams/recorded/:videoFileId/hls", wrapper.GetStreamsRecordedVideoFileIdHls)
	router.GET(baseURL+"/streams/recorded/:videoFileId/mp4", wrapper.GetStreamsRecordedVideoFileIdMp4)
	router.GET(baseURL+"/streams/recorded/:videoFileId/webm", wrapper.GetStreamsRecordedVideoFileIdWebm)
	router.DELETE(baseURL+"/streams/:streamId", wrapper.DeleteStreamsStreamId)
	router.PUT(baseURL+"/streams/:streamId/keep", wrapper.PutStreamsStreamIdKeep)
	router.GET(baseURL+"/tags", wrapper.GetTags)
	router.POST(baseURL+"/tags", wrapper.PostTags)
	router.DELETE(baseURL+"/tags/:tagId", wrapper.DeleteTagsTagId)
	router.PUT(baseURL+"/tags/:tagId", wrapper.PutTagsTagId)
	router.DELETE(baseURL+"/tags/:tagId/relate", wrapper.DeleteTagsTagIdRelate)
	router.PUT(baseURL+"/tags/:tagId/relate", wrapper.PutTagsTagIdRelate)
	router.POST(baseURL+"/thumbnails", wrapper.PostThumbnails)
	router.POST(baseURL+"/thumbnails/cleanup", wrapper.PostThumbnailsCleanup)
	router.GET(baseURL+"/thumbnails/:thumbnailId", wrapper.GetThumbnailsThumbnailId)
	router.GET(baseURL+"/version", wrapper.GetVersion)
	router.POST(baseURL+"/videos/upload", wrapper.PostVideosUpload)
	router.DELETE(baseURL+"/videos/:videoFileId", wrapper.DeleteVideosVideoFileId)
	router.GET(baseURL+"/videos/:videoFileId", wrapper.GetVideosVideoFileId)
	router.GET(baseURL+"/videos/:videoFileId/duration", wrapper.GetVideosVideoFileIdDuration)
	router.POST(baseURL+"/videos/:videoFileId/kodi", wrapper.PostVideosVideoFileIdKodi)
	router.GET(baseURL+"/videos/:videoFileId/playlist", wrapper.GetVideosVideoFileIdPlaylist)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+x973fURrLov6Iz732AdyaMPTh5Of6WYBI4McTX4yTvnj18kEftsWKNNFfSGPtyuAfN",
	"JGAwvrBebMKGu/wIAQcWw27IhkCC/xh5Zuz/4h11q6XWqLvVmh9mZjdfSDySuqqrqqurqqurzmWKRrli",
	"6EC3rcz4uUxFNuUysIEJ//pAUWzV0GfUMvD+VIBVNNWK91NmPLO381vjyt3mrdr+5p+kQ2XrcCabUb0H",
	"/1EF5nImm9Fl77OM7X2dzVjFeVCWvWH+twnmMuOZ/5ULQefQUyv3ma4ueR+cKmTOn89mJuRlKw65cW2z",
	"8eZm8+b3zY3nDKCK92E2Y4L/qKomUDLjtlkFJBL2csV7T9VtUAImBHZcVz6w49BaP9V2X11s3qo1Vl4z",
	"oAH4JQ9cijl/DOxpYAFzEcxAHNvx2X210nrxVbP+dePu3xAl3NqOW3vg1m+yOOCNQ2ID9Go5M/6HjKxp",
	"3luGWZa9/yka+pymFr2ZWAtqJZPNGIvA1ORK5oyH2Mmpmc+7ZUiIgwLm5KpmZ8aPZmnM8ICdtE7I2twX",
	"qmLPU2CuXdl7tN7cvNR4etN1HvmUcG65tVXXWWVgoRIjUpFBfPPxmTUMDcg6wseaMM7qmiErcVTc+oZb",
	"uwdZ8MStrbv1C27toVv/0a0/deu/uvXLyWgFg1NkNIrGRyYAU6ZRMuUyRVa/utfcvNW88Wb/guM6266z",
	"00YX6ZA3w3GJfDErzcmaBcal5u3LxI/eK1cvNbb/PC41vt5ynYeHmdh7OCVj3l9mJi71KDLTYBGYFmV5",
	"7V+4uH/3Ygok8EgJICfVskrRLhr8mT42fkaR0/xYNlNWdbXsLeQR6gqaNEofqRo4JS8V1P8EfKlt3r7Q",
	"ePDIrf3k/Vl7JR1a+HDZBiyGl+UlyxuSitm7o/lE1E4DoFjT8tnjSzbQFUBZUmb4UHKdq42dr/ceOmwu",
	"6O0DJjDj07k5C1C4YaDf6UCCh5RZjyTOeUq254/Ny7oOtJOUCaNV1/jbBUlVMPyKDCXbB18MPu50ownB",
	"Y4QmTKPiywkNKcU0KpJmlKQ5VQNMxJTIICk3XQ+L43rRUKgIuLUtT4/WfkR6lIkCwCN0AN1XpjTwFfSI",
	"CbYSfNopS0LgGJ1pUDRMBSg0fEz/GRMhM/y4A0pg0DNyiQvdlktMDGz4bUfAoc1DA4wsHvac8YedQK3S",
	"Jd/byT2Re8KEWu1U2gu2Ceji5tZ+cesrbv0xBH2XSWMLj9Cp1AUoYJxm5qvlWV1WqarJxg/ZTCc+74Ai",
	"n6sKMFg6aNF7yFdAi8T3KcH/m6fiU6rltm2B1Mud6GGIwvGlolZVQMIK3L/1oPFgE5kkUvRdhmOChsWv",
	"hOipNihbBE0s21T1UuZ8sHXJpikvh/idkK1PTbWk6rLmEZomu489wa29dOtX4OKJmMSN60/c2gX2/j3f",
	"NnzC9g1R+gQsnzVM6jJCZvcztGkwQC74n1NAYWJgSKdlmv8Lx2GYI3IZiAzsa/+PgW5SSfrSrX8H/Ygn",
	"DEAl+GXKzQaCm1wcDfFIuee0IRHZdMQwIQCGSIir4nYEsC4WBI5e9wAXbNm0aU7//uZq49Eq1+m3/G97",
	"5PYjnXzKUEDSxnAHmkTP97aeNrb/zDLRvXFS6kKEwZQmL08ZlopAxxy1i2utG3d2f1tr/bbNokvqwAt+",
	"+cNCHOCHBQYY+CCV04dfPkYBc4wF5ljHYD6ejoP5eJoBBj7oCEzhk3+Pw/F+pANCT1JAOo+f4ojgKVmv",
	"yhqy2X2N8mmFLi1t5nvz8mpjdSOIG7rONtw1brq1n936I7f+YybrmdQVYNoqQGEm1QRF2zCXKeHHh4/d",
	"+iW39p1b/6tbe4bWx+7r73dfrnoDxx4FyyW246lWQV4EBbkMJtjg3Npv3iS8hfgnOPjjyBbnbDWuX3Wd",
	"bxp3XzQvX3CdJ7s7/9N4+g0ZPWinbBYt0iSiefTxNtbXbr3u1lca19ekoqHPqSUJOT2S62xL/oYTm1pF",
	"NoFuT6imIP2I0QO9j8fPShRCec45Ch957zXuvmhcX3GdZ42dr/fvrtAwMiNbjege4X1XNhYBNhIoiunr",
	"ervNcfnK/q0HfA5YRtUsgjb7k4cU+Sq5CjPjf2jbB2MjZ0OlHJnKmQAxY/ZLULQ9vD5QFMK8Yy2v/at/",
	"b914DaO/z9Gq4i6moqEZNEG4/Hcao3Sq0YOANa6vxT9po4Yvkggoa45VDTB1B972BWaGVkI4El+soLuI",
	"9JfifwO1wIxaBoUKKKpzalGmI4UMAhQWRV4pS7J8r1QQp6oGpiMfeLIpL6abUkGOfA5kszgvDr9Avt/O",
	"TBpx2kC0T5nBcqAgyifqPX+bWLneuHKnsXO79fSGp648FbzD4H/y6g0CTe3zCwZgYk0sR9aqSIOxjR08",
	"EQ2I3Ld2nNEQHIQhN5jnR0JommRQRkAEqVoRP2GjWqV6lFEFIIhwVUSLEx5ABFX0Mw1P8RBBWV5CYeD3",
	"3n336Lvwn3g8OBzQBmXa1B3s+a259SforC+uz9EQVC/ef4ZPEAWiEfDV89nMPD5ToXu9wWwb19cOoWOb",
	"w7TtY162Jo2SMSHbMm1+T93ai4CLbm29edVxne9c56HrfMXZr1UlRWyFtYeRU6DufMA+a5gLyWJ0OngR",
	"6ltzUS0KCF8heDGmZaHhEDwmMcni/TTKHmRM2OCYodumoX0CluG7JPGjshD8lTkTFUIrEhUSobAnubF4",
	"UTAm/ewakb75433yyBqfRkMfCLp10OnyPJUzFPYcg/YpTQn/CFfMhmfT1p7HlsusachKUbYo3n7z9uXG",
	"lV9c53GAH2PJIQ81LpfHGL8jHzD+u++0cdy6RIKEugmIbahu/X4YEBMM/3lm0XFdntWwvYS3JBQrYJmk",
	"zZcrrrMD/buoA4h+jzhO29TghutcxUxhaAIfr0l1EbCQces/QCibew8395wXwmPOFFJOU5opSD2Z1YKh",
	"qCcMy6bkWHiPpHn4LA3/sFNCEXpoxTauPdur/+Y6j31nguYSpgJoGcUFYJ/8dMowKSsNPT2iGtL+hT/v",
	"7txznUe7v+20bmz5flr9fyC9CNeR2DPRuQd7/fOCZNF1rKmLgCMvaYaa1yzOSNKJyYKUEL4TJm05b3Nh",
	"ncrPCAPjaXhvHD8YKJtymYWKpiUiM2mclSZlG+jFZelQuQJKtnXkS0tq3dg63DuqVMa4eEyN9QzUWTDL",
	"UzPSF2D2VI+AnacoevZajuijFMKLtg6FHVroUH2nWSvioHq7mGhikwKX/stVCmT6LHi2xRc50f0vvVgw",
	"xz8oWWAjcFACwMagr1wX+SWbqZoa3DUou+ln05NSAT6TGNa0QmRUck/KpifRQCf1OYPcCFN9BLMEUn7V",
	"ZpBDuHikbIj/GRqtyA8jRlGWcEUIpR4Y8iRVqYYux1JNMtipsQ0TyDY4Dc7id1kh2ebm872H1/x4LLTX",
	"kIS2Nh63fvqKH6U4mc5zjwCOZblCeHs//Nh68ZzmwAOcyC16/JrNAGYmoj+51XuNX3+iAYNH8KOpj979",
	"D/Odfni0gw/p4RA0QUYsJF08LRsciqcivlWd/bgDKubJb/NdfHs09bdtyzuSAhSkBeBbAZDs7IWnECuP",
	"tQeQK8x1ttFC3P3tdnPlumggt5NjN/YBF206RDIpzUi+DNPh6/A886nnDJP5x4wNwjQqx3Q7YbTaE5xu",
	"T3cbgWkaJn0Yz7b6AZIsYYzkwGM0lRaemptyeVZT9RID9i/Qx/4BQt2EZ5ZcJGjBwmBq2YBW7YATOEXP",
	"uOHxCoW54yQ6rqg2yg2Ybj/7attGYBoAOoZo/by1/+3FpDQAWdOMs8d1ZVIuLtCid08az980Vi65tatu",
	"bX1v62/e5sSIsPTiqLDLkzlbLolHW9vOgCh2GykUEULROJ8y1ZrCZTSAZx0lpnvQF7VZ1XVVL6ULOkfS",
	"TVih57Oyavd82NgZEYE9CZJNbXJ4oWwPtOJ+cOt3GSRUU5x0ZjOaUWIcwVCtJ6GsFIa5UAFmEdC03f6F",
	"vzfXboaf6NXyLBIoMqghtC9BLtGUYZBe4Q9I5YinMOFFx7bUCNqcT8zMTEH36iI+p/olIEAmm5kzzLJs",
	"o+VxNM/eeijOLUKDRnxgWXIJ8Laq+j1PM9deQ5xeMvIwZOVTXVvG6V0RWwVRCQOiEUkgH5XhyZfwlykt",
	"U2yJdWuIIfi0ObXHNGOz815o/Ha/8es1eui+/kdI/3sMA0u1PtOLhr4ITJvqRXx1r/HgcvPat6x9iW6b",
	"793baj14lSLdJooGlRD0LVrWtE/nMuN/SFArjD3+/JksZ5NP2t4r5A0cwdsyWXiv2M9I4bisRMJOEhqd",
	"eaodOJsdOEkpHI4zQoGb0+Qhd1tiO3qUKp3B58wHVUU1CnK54lmf07LNdDchL371T5tqj93aT1CvwFRH",
	"f739NTgJ8g+IR98bGRnJ5vMj745k82Pe/x/Ne/+OjY16/74/MjJyhoNboG+SEu2TRsjTRvgJHhuJjZN4",
	"1YxC9CTKw0zDaWAZWpUXNAmyV/cefdeoX2u8ekgcwOfHRiqZbGbs/REV/cf76//m4X9GR9Cv3n+9v/Oj",
	"76GXj3rPaef0JGL0bIA2lPDeegnub88IxMoVUPI22Pkj+ffG/P++SwWKrQR/iU6qlk23u4j01qsw+eSB",
	"FCwqCSYQP0b7QI/URJFqFaEA78bzZHevCF27EDZNtePJIzlNM3W4byZMO+0Esh1aA9SJszd23t0VMoCO",
	"hI3l1kSsS4EgTNxF9TTfMTw9LO9xQDJNQwrQJ65Zz2ffRmzVv+ybIhrye0SW/aGaMgtetaBj5000yUPb",
	"ffmUnecyZRo2KFIt1b1LjxurG0jiUQp949mbvb/dgxcPWeMhLKlooZE42HQQle7MYDR5BQdIoZIOnVJN",
	"eaFqVnV4+wGLIpHoSBzK/x4hp3/baZiLFtkJLhiLj0heaaaMCM/wBPR1cLdYHHJw6YMJN2qnCdC13brD",
	"AxVwRpTtR10YExDJA47Za/T0VPrxRlQJRBRVVN/wtnDyCoIlYrc0H9xuvbjf5tfxzyHTi2S7KUlhKtT/",
	"6UeO2mlJkcdgAgE8Hi059xRYBEp1PUhVUkeuu71RpBJp0OxrRUlX6OF2FJawYJuCM77+Yt+5YhCyp4rP",
	"sGm33fDhybXd1/8Qch8gTng4NtnYeTiMWH74VarZshYSY7q+/S0+XYwXf8aabAPha3a+s+psId67zvb+",
	"5v39C9/tvv7Gdf6YFFs6iPNXPyR3TKela+FIXOSIsV0BoPJvlK9bT/7RuL7i3xxieHt+GTlK6P/PjZcv",
	"+d/6deZo4ndpbe/BJf7X1oJa6Qjp9hhqeyE8K4MHJ1DkkD56UsjkQfTER/QK9Kh4hv9oPI2b6svhofPi",
	"Q+dTDn1UfOijYkOjE9wpfLMZgTktl0EaAlFvP6eCloZm3UNLQ0ZhaKo1ATRgB1eRP5izgSl4PbPx5qrr",
	"PJFsSxK8al02lFQcYh1NpqE7a4w01Ew2SzhUPBPqBnZhK7Yhgj6khqR8C4AbkmrLmojzZHiDVmyFQ32K",
	"1tVERJUmvZQXeekonWDorVNY5Hkv5JNe4IJgqcGUeiylIup1xuU/ewgvuBvt6dxjuMoudUkm6GTaB5/6",
	"RXoZjwsLKvPZDHmGSn8Je23s2iKhcNDf60WwjnkX5iM/CePc77mrfY/M9SCSNsSRL38lRZYwufyy0Q03",
	"vrz4izvbaRaxr17Y532+24FP9jyu9ygFo5PyENkuazRwy0kQtGD6wFkJlVHMSsi3zErIUXSdbSkYPeEs",
	"lPSUBeZNxvhCNznlh6SPnPLTwEFO9V2vveOCzM4JRqzxi2Z1XhTMH0DI+2HsX7EqWWnGjO9K7Jrbjetr",
	"8E+U1PcXVN6L6m2wCGrxmwOwqrmk0f2hB9LH4GSAFzdc5xeJEUtUixaXOp89lzqDNrQLMHrUNH5fcAVn",
	"qtLUVix3Lqh8g+fNLYvJdB+rGvBrpDLStfEIbQVT0alK66frzb/cjuc5psqvJnEQOeNQmanU7SONd8PR",
	"hbB0rMCRA36bhVbCdYeAzGLJkGnvOjSuPeMHXuRFQ1UmqhVNLVIT8tpqWaBNEWfprTf/ez0xtAPghUOe",
	"gCXVvagAUzWUGeODJFwhcm5tfd/D9Y9ubbV5+87+5p+oC6CP9yz8GcdMvjZasySm0FabjUE26vEmoyYN",
	"pWoqq0wNpfIpq3INpXops5gNrQJp/OXAyLU4hZlEC1VEIkTtuxM3zan5sLb30JEOYRJHFOBhKuZK1YSF",
	"707JS8z0EdhGA7dEaqxcPEwVzGAkVeeN9Pxa4kjsJCmUwZVqguEpNr8OtQhnUDY/rZ5QSTdMMCHCG2Sm",
	"p5gAGvt4Ik06HPgTsExbQB7HYeMaj2Hof66+aqx8jzRe4+pmNwCnQen4UoVCo6ff7T28tndvq3XtTTfj",
	"0yuoc8ajniPA0U7z87g6wRI1FkrocsSopNQxs1IguCDKoHRj0pkizA49iREpsEElPqfg9myxcEIJgsFO",
	"LKQgCsTAVN9CLdN0EbrP0Xr2VePbv6cDBZvYCVU78XZoi7cts+41pkkSg+6MuE8VAE/jVkGEeD5VoTgP",
	"FGrxTT8N+N4W+0o5UX6SS30fBtyrtcCX9ANOlujnxCVKi5UalSGGPUNMjwTNmamzHRggibPuqLDmv1hF",
	"TEppSsq8H7v1+6h0Y2vjcePaz/QMj4Mqrsmqm0mKE/c+LylO+H4LS5b+Ve4M/J793+nRYSTa3o051Enp",
	"l76ky//LHLL9qxyL8U+tgt6g6PiKrkXFrSaaCqYYUfg1fpzFl2GhIIvaVffS+HrU6N1AydCr31QXhhTa",
	"Tb6wfILRmwL/Bi7iT06UZzKm5xmVUaQXIOBdJLHprVzGTr6AjSdKb6RN+jRiN9VNWafViCCbVrnOqlu7",
	"7Nm0xOiHmrdqh6VR6R0pfzQroSe4jUXYvKX1aN11/CiW62zvb/zsOhvQIoW4oe5zo9J/Se+NSP9Hetf7",
	"Jz8mtR6tM4r2ymZCg61EjKQR75FbW5dGJNfZcp2brnNHGpH+SzpE4nBYekcalSD6b1znEUzRJigSnQEV",
	"2bMA0ILu395u3vwefSyNLI2MZr1/8/DfMfjv+96/oyPev/kRKTuyNDYCb6nc/N69cLtx+47rPGk8e9PY",
	"uY21wrbrPJJkXZGav95obXtaAwFJRrJN+CDGdInTFai6J1V9Ycb4xFBUliJcMBTVdV4SnY3QJfxnbm19",
	"/4IDyzQjtLdcZ02gbZM3ID0c5DcX8swEWNCa3byobZ7BkPS5Eu5BW8Fp9ChVMQPYFc7vkckodBRp1OlL",
	"GT0sYBHtPoV7ckbVi/+AOnPbMOUS4KP5V1QqhlVMKN0O7APs7jSPHCUJbVQfvHXlH80fnbgLtSirGv30",
	"qfXDK9dZa2z/sn/pmnRo1u9nTbm3QL+W5Jem+MWtPWMYyIxQTevna8lAqxbNqkZT5X5KL/sSksEfmhv1",
	"SdeAlrY+yKXRnTThkboWqMhASTM7uFql1GJCB+owczBge9G4iiyvhQdxqCsdOjFZkPzySXjjRk8Pp2p9",
	"x6tlHLN9WRcKmfNlebod9qTrzJdNvR9gjEXex8HGxd60tCM6TduofYxfZC2Qj6gDiBvfiljEIb5Jq9V1",
	"tltb2/v3/kKUhImUQ/b+ODFZyBBXifEj/IP3mFYwhtv5Gpb1uevW1/iVL6NFozmFsOPbl66YhkrPgVcN",
	"euHuslyk/n5W1ekJLTHSEwLJcEakQ2WLvnF9VtEMWQlkhp3DQOuSWVt3a/fDuqL4BCtKkzm/fmxQXm9W",
	"1WXYwjQ2Ze9VkUhGgC5eHv3M/UutRaqzE73JaFxUwdnTXdaRizSxpJGJAEMwAP0vdaF/DkyLISPXkYXH",
	"vbe/GH7Oxxy/SMUhKMkgJqkMXLw5ssxFyiiM7UZNp5LZFqoPEp7pfgFmd19ecZ3tgNXUtmyW+p+An5bq",
	"6bzaA7f2ip5TlX61cW7x+3sKRIrLtgk/Y0ZU0eCoRTx3mDlQY3WjdeP1/sbPh1qRlnbY3GibRjAQF2/6",
	"kRcFY9bWEqWloNhBM4zYK2GmNm71Et8Evamp/s6lqUWgWxCS3zD61MkZ1JEgM56Zt+2KNZ7LlVR7vjp7",
	"pGiUc9pRW6/queNTHxdsSJDcrGbM5sqyZQMzN3ny2PHThePoQN/2ll8GVEqWjTuIBos7kz8ydiSPAppA",
	"lytqZjxz9MjIkVGohex5yLwcWcOjBGzOQaZfKr22TgZjM3B0xDePM5mPgX0srKphAqti6BYSlPzIiJ/p",
	"jyPpcgWl9Xlz/NJCIiTW6T3SZg+SWxTrmzCSddN17iBHY06uanbP8EJVaCkI7b5aad6+AwE/hsfPfu1Z",
	"uAqsarns7ccxvBHSGZx4SVQsOeN9F3Avdy4wGc/nNKNkJLMT3saAJ+TiHA18tEkPBNzM5DKwgWkxs8fD",
	"V3JTsj1PeHlnEsVDLcslkKvAElgcFtNmEuXy2AilGc1pw5Y+Mqq6MtBygGaWKAdBAzcq0/0QofgKRsP1",
	"c/0iCBQCsXAd7HUbwTrOLTRbxCu/3J+VO6eQPQPOM7lH6R2QzEK/WqAV7UvQyZJt78KQ+JH/8il5qeBZ",
	"IQIL3QZLdq6iydDdivOAS4C0K31s9D1Ba811rjYePILh+Vuu898eoQdQ8uLEIQQPy5ovemFbU7qg0ZoN",
	"CMhacN0ynXCdJM5FBYSkCxKHDRYodE6a9WArHir2MQUEwtoZFcNKZr1bWyd7UsWYPmVYIdc9Gx5Y9oeG",
	"stwzsnygKKgoeqTfQ3DSHvEcbLMKzsfEZ7SXuAQt9pPlx/MXfdI9QY2EhkZ4EN40sQmVR+4cbux/HkmR",
	"BmwgIk8wNxpeeai9hv4kVbDQZW5E7KDhRie7Vtitg6FZUuM7VHogPgEWW9WKvYj9iCPlo9X3mdvDyamZ",
	"z3FFb0lTLVsS2BtOVuxF3+g/5Q2eepOYmvk8slEk2x8oUH0KLtd028rSO+UKKH02PUk1Q1hTH2zB4HCN",
	"EAlPCkiBAJXSkaWyxpcFUCmJisDxSun/lbWD4L73yYS8bKXmPZxtnMxtkxwCZkcwpvOY7BBE5S9ZolKA",
	"xdNhx80ubMBk5n46N2cBW8gJgdmAIvJiTYNFYFpA5OV/qwJzObj0LPY6ebAt9gWZ+ir8Eb55Jvr+CdnC",
	"NVNQYeV+WuC4FCpFshmSNtjrjEQ6ts7CbllMc5vSgrK2Trag5NjdxFrrh+XNal17wEY3pZEnU3g4rTyH",
	"wAhPnANdtEg1nitqQNar8M4kT+CgVfgMJwH8GJ4cJ0vbMR+CiDGdBGwY1jYLewFmGGG1dd7eSkuST7HV",
	"4prufdfa7UXk2To8YUZDodK5cxBg/rnwtJ/rIAdSRhZ6ZbjDmA/TbYkEKV1iMkfiTKp1jHEckoWL0GXt",
	"yJw1idIHU1u9PeRLdnCipm3dQRmLnkEygag8TsrfcGtXXeeOpMIKcRJlWOcqYvzgCh2VCim1BRGdF4+q",
	"NZzbzaf3U2qPDuP1HekQNspDFU9DSKflaAX1aIFmWZVnlaEOUWRvKHTZCNX3YJlnVYoG8tvCHPAGkYT/",
	"kGwc/Gmk5X5V74r/T5orr13nlhjbPwtgvX3GI8SHmOUh5bn89nuzceyJ3ZdPUxoTqLtTOg72JSh2oEYG",
	"x6mgkXAYRCvAm2ELeIxuE6acCSxg22oZmGxHHlc83IHJCn+B2b7rjYtr6EpHoiOv6qXpEIrIUk8CONjM",
	"iGMfoM5lSVjVlbq8yZqwQms7qMb61pd2iI6fud/rGH0kRt5f3eFTlS4eNAYNg7Ay1YY/W3ZUGQt7cu4G",
	"IZD9iCFT+9m/haQNHwO2gAxTsgbCOJajQcgFqbpyRb9nGU9/bTxPobxgE7T+L2cIhr2iN54P23LeeM5b",
	"yxGeabjIPodpQQn91LsPKuGfdgsq+BcPBTT/cXgz8SB0PpoKe1kzaTQU1koUe2HpqVYUv5AZb3sIj5i+",
	"fdHc9FYTqrUgsFt8hgCIW41sWMOzEQfYI9QF+HAuaHnBPQEIdmuhEwA0dtj0ozM3P2gZciaN6T8k8X+E",
	"LiX4TxhO9Dsx0Uh0h8Z9z3gzUO450a2CcgVHiHBDfxeHM0tnO8FQp4X9mpdXG6sbwerylSMnyNuPxd97",
	"q/+4otrdWf4cMgV7yOAb6iTeCOl0m0bOCLvPJWweQW+JK/9ofr3qeX6Pvku9l4Tdtg5sS2HiPRT2GQP7",
	"lFy2/CaCySyGpw9dsdhvs3aQ/KUjPSz8pWHP4S+u3si4vxepci5iUvhlxocwWBjNRe2rbQKJRLuQw6T3",
	"gB85R/GOGxZwwpw7XGHzKYEIoC9ifbq8RXYKexuBP1gclSMaQ3VLCyMdj/35EhHooBzR6oKvi/AFofYe",
	"ZQlKCa/sAdBNB6tpyLZvXMFi0BUVIB4+XcSaT1/1Uihlv6unfyr1dA41quVfHSXERSQ05g3sHzd2ZOHy",
	"TyqTcRuShRyPiwXLNnGnELJX+8eDninxJM1NZ2ma7FWPqNJAJ6yGAsGxL6sJApEYsuqlQAzEDsBVBkMU",
	"nAqdjFhkiqmtc4pq4cq1iaLR+uoeavsmJB0T/sgHqrkJFIdEeQcYi/Er7B6bvJJxlz4hdgUVag+QWwSG",
	"w+K/Y4wZ3LLIhh/UzTdoeSUcMgqbiPT/gL/nKWOnAVCsaaI5khCIj0yAC8OIfIA1/MfTad7+sJDm7WOp",
	"3i588u/9tXlCoaBINVvGBnuZteEdM2PC1dW22nKzpiErRdmyeZnbzRtvmt/c3X35NOg2FwBJsww/JGGl",
	"XZIfKIo3qN9fc3COg7nyJEa4gS+/yZqDkIQpwJZVLXeugpvMsav6tTkQXWj8CQg07GvXye5MdsUbPHmL",
	"9CZLTEMQVWxDn4nQuSZEPYjZqWJkH7dY5JIZuwskEl0Y71P4jtqJTtyHE8ahd93zWHvvUEaGOagLiR5R",
	"qVhUN5KVfrvQk8eIrhpdVS7O9tKmRrWqBtGkfnuWRCfsH3DDQnhKyUsJNfri5BvQepSJLBQ8cD/5TjRX",
	"o9bS5KM+6HfGKdjH+YnJjNlpAr9pO+tEpPH1Fmxavt3exEfo/n/BByASdxGANNgsSJxAhBGIMOwjEFqH",
	"M6GFhCk+oAWRiW5znEXImvZwLEI69lT2E8swp6mLINJNYV7jZXb9AO+VbkonJgtSXOS4NytCQZlUF0Fg",
	"XpzQrIOwTzotkZpW0KJtP6nnb2I0HPTYL2cW6YWunLdFpO5UfoZGMkH9FBG7U3l74OQOdtzLlSt5m9EW",
	"gEeHwZYSKsYdiUmuosnLmoq8+E7kpX4TNkF7EFw760KCpjAuA6zB+EWeuyDWsGgosYl1Jo2aJiqGk8ZZ",
	"aVK2gV5c7qEK07ThVmIcqgyBUJHYH/JWmW0d+dKSWje2DvdA2VXGBGSrXBnrlThVxgZVlsYSRIlChMGW",
	"HhrCqQXkLJgtC0jIF2D2VI9E5AsP4kDKiE8LnpDQ6DDYUkLFOElMwtpsRANnvluHKjh159PhkmpE38pO",
	"Pbto61JBcfEssSnDUtHpyFB5hELkH4YaYB35ggx55e1+PrSutj6KvHa6AQ6gvPI3Tjb9Bli2OtkyGbLF",
	"3Th9cN3tmhTp6njvHFjxYu65HBIOsIB1tNueQ/+T2B2s83MMf+/o7BA3+Fi0ePFwnoKkOvygsy+3AECF",
	"nUEcBeBTJVojMumOQBs/P/HgHTxPuagPFZdFmEDnPvqVeZq849bEa+LPeGMNyu3Q03JZ/NL68aWiVlWC",
	"cukzcqn/BSwDUPSL7HTSD7pUhkjHztzgf3ldSHdQc9/Ea6K+mPXrclDImLdavTLAgi0dw9Vu1MM4dk3U",
	"FwqsiXLnbG/pJRgQvqAIXBD1RAUt5m5Ko/PVQQJ2w7BiY/dDw7VaZS7VxvU1b5oPLje/fcHe6XvPgUFa",
	"9WwBGKZrgZidiJfJqzNnAk22QXKLI5Te5jpbAVH2N+/vX/hu9/U3rvPHlEt4GgHtgRiJ1rHurDOC8KSH",
	"IYwlOBlh1UEftbYeGTVZmfROFvqkUhCCvdMqQtwYrn6HTPZHvBVSBc1Xy7O6rKLoPcuK/AmeaK9BR+iJ",
	"62w3Lq61btxprlwXqXY7E4IQ0/Ui0AbdAojMIZgAyYOQKu2cSO4+2U6j9G0oQ6akaUQpDHeo2CPQmpLH",
	"rXPB//OuYMRhJnr+AYiZEEBH6pn8XsABV8tyCeS+rIAS/cSTOZOh4jqPu4vAtFSEG+Pw+zpKSUf9LIWD",
	"OZ/74/YxBoJBUDND+VgPer4VBftYQARzzuejqgDDylUrmiErPHWKFVf9qd9WD5LBrf/JrV+CzUs33Nq9",
	"QN4ToynwSMX6DIHlGUPlqmarFdm0c3OGWX5HkW1ZnKJo/OD4JrSGBH2qziY96Iu8k1mRAgRZF5WfyOke",
	"v9QWHYqAS4ZEhjyL6/osT7AyCB/lQVcKFOxp3GQW5WLMPkmR955bItcJJ4yzOtQpKcPoRtEG9jvokMLb",
	"07NtWZTZ6IF+tu0AFv+99E5Ztk3DWpAZqVB8Yv6TiBJLMeSUKhISptnQWN1o3XjteZgbP8Ori+nlbALD",
	"6Jd26I0RggEF6FL4wqbGgF+Ji+KdSkQWDEXl2CGhCD6Gjsgzt7Yued9IrvNy/4Kzu3Mv0eogmPyJB603",
	"gtKHsgNAR7bLpKovzBgerl3XjxMl3xDpIuZMUsmdwJ2WAGIH11diktfVvZUu1FTSXRSRSQ6NaHBumIQS",
	"4X0MzEVM/qqpZcYz87ZdGc/lNKMoa/OGZY+///777+fkigrp7Q9yLqPLZZAZz/gp4aiqAv7N0OfUEvmL",
	"YhqVSaMUecvvwE78olbsRfLvoBFw7DdVL0V/xM0pid9QwYPwh/BqP/kjvh8e+Q3laxA/wVmTf4dBAeJX",
	"7F+SPyFanz9z/v8HAAD//0bfiB2qLAEA",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
